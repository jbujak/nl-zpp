%
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[licencjacka]{pracamgr}

\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{wrapfig}


\lstset{
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4,
  escapeinside=``,
  frame=tb
}

% Dane magistrantów:
\autori{Michał Borkowski}{370727}
\autorii{Jakub Bujak}{370737}
\autoriii{Marian Dziubiak}{370784}
\autoriv{Marek Puzyna}{371359}

\title{Kompilacja NianioLanga do efektywnych konstrukcji języka C}


%\tytulang{An implementation of a difference blabalizer based on the theory of $\sigma$ -- $\rho$ phetors}

%kierunek:
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{mgr. Radosława Bartosiaka\\
  Instytut Informatyki\\
  }

% miesiąc i~rok:
\date{Maj 2018}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{
%11.0 Matematyka, Informatyka:\\
%11.1 Matematyka\\
%11.2 Statystyka\\
11.3 Informatyka\\
%11.4 Sztuczna inteligencja\\
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.3. Programming languages\\
  D.3.3. Language contructs and features}

% Słowa kluczowe:
\keywords{kompilacja, języki programowania, analiza semantyczna,
  NianioLang, system typów}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}

\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
W pracy opisujemy...
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Wprowadzenie}
  \addcontentsline{toc}{chapter}{Wprowadzenie}
  NianioLang jest językiem programowania ogólnego przeznaczenia. Jego twórcą jest
  założyciel firmy Atinea, na zlecenie której realizowana jest poniższa
  praca -- Andrzej Gąsienica-Samek.
  Istniejący kompilator umożliwia translację NianioLanga do kilku języków,
  między innymi do Javy, JavaScriptu i C.
  Ze względu na chęć uproszczenia kompilacji NianioLanga
  utworzono środowisko uruchomieniowe dostarczające odpowiednie abstrakcje
  i pozwalające na korzystanie w C z dynamicznych struktur odpowiadających typom,
  jakie są dostępne do użycia w NianioLangu. Takie rozwiązanie nie jest
  niestety optymalne, szczególnie w przypadku niskopoziomowego języka jakim
  jest C. W tej pracy opisujemy wprowadzenie nowych typów danych i ich wsparcia
  w kompilatorze, co umożliwi generowanie natywnego kodu w C i znacznie
  zwiększy wydajność kompilowanych aplikacji przy zachowaniu podstawowych założeń języka.
\chapter{Wstęp}
\section{Wprowadzenie do NianioLanga}
NianioLang jest proceduralnym, imperatywnym językiem, którego celem jest
uproszczenie pisania rozproszonych aplikacji stosując wzorzec projektowy
Nianio\cite{wzorzec_nianio}.
Celem twórców języka jest dostarczenie narzędzia umożliwiającego operowanie na niemutowalnych strukturach
o semantyce zbliżonej do języków funkcyjnych, ale prostszego w użyciu.
Konstrukcje takie jak wskaźniki zostały usunięte, a w ich miejsce, w przypadku kompilacji do C,
zaimplementowano system zarządzania obiektami
w pamięci przez zliczanie referencji, aby pozbyć sie jednego z najczęstszych źródeł błędów, występujących przy programowaniu niskopoziomowym.
Takie zabiegi zmniejszają nieco wydajność języka, ale jego twórcy doszli do wniosku, że zysk z wysokopoziomowego podejścia
do pisania aplikacji jest wystarczająco duży, aby tworzenie aplikacji w NianioLangu było opłacalne.

Kompilator NianioLanga jest rozwijany przez firmę Atinea, która używa NianioLanga w swoich projektach (m.in. InstaDB.com).
Kod źródłowy kompilatora jest dostępny na platformie GitHub\cite{github_repo_nianiolang_original} na licencji MIT.

\section{Typy w NianioLangu}
W NianioLangu mamy doczynienia z kilkoma wbudowanymi typami. Wszelkie typy tworzone przez użytkownika, to właściwie aliasy na typy wbudowane,
co pomaga w zarządzaniu abstrakcją w programie. Dostępnych jest pięć wbudowancyh typów: 
\begin{itemize}
  \item \texttt{ptd::sim} -- liczby całkowite, zmiennoprzecinkowe oraz ciągi znaków
  \item \texttt{ptd::rec} -- rekordy, czyli odpowiedniki struktur znanych np. z C
  \item \texttt{ptd::hash} -- słowniki o kluczach będących ciągami znaków i wartościach danego typu
  \item \texttt{ptd::var} -- typ wariantowy, który reprezentuje obiekty, mogące być w dokładnie jednym z określonego zbioru stanów i dodatkowo
  zawierać dane o typie właściwym dla danego stanu
  \item \texttt{ptd::arr} -- tablice danych tego samego typu
\end{itemize}

Typy te mogą być ze sobą łączone w bardziej skompilowane konstrukcje, na przykład \texttt{ptd::arr(ptd::sim())} definiuje
typ tablicy wartości prostych, a \texttt{ptd::rec(\{a => ptd::sim(), b => ptd::sim()\})} definiuje typ rekordu o dwóch polach będących wartościami
prostymi.

Podstawowymi założeniami systemu typów w NianioLangu są: niemutowalność struktur i opcjonalne typowanie.

\begin{itemize}
 \item Niemutowalność struktur w NianioLangu jest pojęciem słabszym, niż w językach funkcyjnych. Oznacza ona,
 że język daje gwarancję, iż między dwoma kolejnymi dostępami do zmiennej jej wartość nie ulegnie zmianie.
 W klasycznych językach imperatywnych, posiadających wskaźniki lub referencje nie jest to prawdą -- jeśli istnieją dwa wskaźniki
 do jednej zmiennej, wartość odczytana z jednego z nich może się zmieniać nawet bez jego jawnej modyfikacji.
 \item Opcjonalne typowanie oznacza gwarancję, że dodanie lub usunięcie typów z programu nie zmieni jego semantyki.
 W skrajnym przypadku można usunąć z programu całą informację o typach i będzie on działał bez zmian
 (oczywiście może to być ze szkodą dla łatwości utrzymania lub wydajności). Jest to podejście przeciwne do stosowanego
 w takich językach jak C++, czy Haskell, których złożone systemy typów mają istotny wpływ na semantykę programu.
\end{itemize}

W wielu językach istnieje znacznie więcej wbudowanych typów, jednak powyższe są wystarczające, aby zbudować skomplikowane aplikacje,
a jednocześnie dość proste, żeby rozpoczęcie programowania w NianioLangu nie było dla programisty wyzwaniem.
W rozdziale \hyperref[sec:compiler]{Kompilator NianioLanga} opisana została implementacja powyższych typów w języku C.

\section{Cele projektu}
Celem projektu była modyfikacja kompilatora NianioLanga, w taki sposób, aby kod wynikowy w C zawierał mniejszą liczbę wywołań funkcji oraz
skomplikowanych
struktur dla prostych typów istniejących już w języku C.
Dzięki temu zmniejszony został czas wykonania aplikacji, pozwalając kompilatorowi GCC na zastosowanie dodatkowych optymalizacji.
W tym celu wprowadzone zostały nowe typy z przestrzeni nazw \texttt{own},
które będą bardziej niskopoziomowymi odpowiednikami typów z przestrzeni nazw \texttt{ptd} (rekordy, tablice i warianty).
Dzięki nałożonym na nie ograniczeniom możliwe jest znaczne zwiększenie wydajności programów pisanych w NianioLangu przy zachowaniu
niezmienionej semantyki języka.
Jednocześnie zmienione zostały pewne podstawowe typy, mianowicie \texttt{ptd::sim} został rozbity na
\texttt{ptd::int} oraz \texttt{ptd::string}, oraz wprowadzony został typ \texttt{ptd::bool}.
Liczby całkowite i wartości boole'owskie mają w języku C natywną reprezentację i używając ich bezpośrednio
uzyskujemy prostszy kod wynikowy w C, który jest łatwiejszy do optymalizacji przez kompilator GCC.

Skutkiem zmian jakie musiały zostać wprowadzone by osiągnąć cel projektu było utracenie możliwości
kompilacji NianioLanga do języków innych niż C do czasu implementacji nowych typów w pozostałych językach.
To zadanie pozostaje jednak poza zakresem niniejszej pracy.

\section{Podstawowe pojęcia}
\begin{itemize}
  \item[] \textbf{AST} -- drzewo składni abstrakcyjnej, reprezentacja programu w formie drzewa, w którym każdy węzeł
    reprezentuje konstrukcję języka, a jego synowie reprezentują części składowe tej konstrukcji
  \item[] \textbf{nlasm} -- język pewnej maszyny rejestrowej, będący językiem pośrednim w kompilatorze NianioLanga
  \item[] \textbf{parsowanie, analiza składniowa} -- proces przetwarzania kodu źródłowego programu na równoważne drzewo AST
  \item[] \textbf{analiza semantyczna} -- proces sprawdzania programu na poziomie znaczenia poszczególnych instrukcji
  \item[] \textbf{translacja} -- proces tłumaczenia drzewa AST na język pośredni
  \item[] \textbf{generacja} -- proces tłumaczenia języka pośredniego na język docelowy
\end{itemize}

\chapter{Metodyka pracy}
Prace nad kodem prowadzone były regularnie od połowy października do maja,
z wyłączeniem sesji na przełomie lutego i stycznia. Na rysunku \ref{img:commits_over_time}
przedstawiony został wykres zmian, które wpływały na główną gałąź repozytorium kodu.
Co tydzień zespół prezentował swoje poczynania opiekunowi, co dostarczało stałej motywacji
do implementacji kolejnych elementów projektu.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]{commits_over_time}
  \caption{Liczba commitów na głównej gałęzi repozytorium w czasie trwania projektu.}
  \label{img:commits_over_time}
\end{figure}

\section{Korzystanie z systemu kontroli wersji}
Podczas pracy zespołowej niezmiernie istotna jest wymiana i zarządzanie fragmentami kodu,
jakie piszą poszczególni członkowie zespołu. Ponieważ każdy w zespole pracował już
wcześniej z systemem kontroli wersji Git, to został on użyty w tym projekcie.
Dodatkowym atutem tego systemu kontroli wersji jest szeroka dostępność darmowych
publicznych repozytoriów kodu online. Kod projektu umieszczony został na portalu
GitHub, który jest największym serwisem pozwalającym na hostowanie kodu online.

Początkowo każdy w zespole miał swoją gałąź w repozytorium, oznaczoną jego imieniem,
na której wprowadzał swoje zmiany. Jednak w trakcie pracy za praktyczniejsze podejście
zostało uznane tworzenie osobnych gałęzi kodu dla każdego zadania.
Umożliwiło to pracę nad kilkoma niezależnymi zadaniami jednocześnie i ułatwiło
przeglądy kodu poprzez tematyczny podział zmian.

GitHub oprócz repozytorium kodu, udostępnia również narzędzia do zarządzania zadaniami
w projekcie, co zostało wykorzystane. Każde duże i średnie zadanie było zapisywane
w systemie zgłoszeń. Po ustaleniu osoby wykonującej zadanie było ono przypisywane
na tę osobę, a po wgraniu zmian na główną gałąz zadanie było zamykane.
Dzięki temu w dowolnej chwili możliwe było określenie nad czym pracuje dany członek
zespołu i jakie otwarte zadania pozostały do przydzielenia.

\section{Zgłaszanie zmian i code review}
Po napisaniu kodu rozwiązującego dane zadanie, zgłaszany był tzw. Pull Request,
czyli żądanie zatwierdzenia zmian. Aby zmiany zostały zatwierdzone i umieszczone
w głównej gałęzi projektu, musiały być zatwierdzone przez conajmniej jednego członka
zespołu, innego niż ten który zgłosił PR. GitHub udostępnia widok naniesionych zmian
wraz z możliwością dodawania komentarzy do konkretnych fragmentów kodu. Możliwy więc
był dialog między recenzentem kodu, a jego twórcą, tak aby ostatecznie zatwierdzone
zmiany spełniały oczekiwania obu stron.

\section{Techniki komunikacji w zespole}
Większość komunikacji w zespole odbywała się online przez portal społecznościowy Facebook.
W początkowej fazie projektu, głównym tematem dyskusji była specyfika języka NianioLang,
z którym większość członków zespołu miała po raz pierwszy styczność.
Na dalszym etapie projektu, na konwersacji grupowej na tym portalu, zespół
ustalał większość detali implementacyjnych przed rozpoczęciem ich wdrażania.
Ten środek komunikacji był najchętniej wykorzystywany ze względu na najkrótszy czas
reakcji członków zespołu.

Drugim kanałem komunikacji były zadania i PRy na GitHubie. Zadania w prosty sposób
opisywały co i kto ma zrobić, a opisy PRów określały co zostało przez daną osobę zrobione.
Ta forma komunikacji w projekcie była najmniej używana.

Ostatnim sposobem komunikacji były cotygodniowe spotkania podczas zajęć z Zespołowego
Projektu Programistycznego, po których zespół spędzał 10-20 minut na dogadywaniu się,
kto wybiera które zadanie, a w przypadku pytań lub problemów, na ich rozwiązaniu.

\chapter{Kompilator NianioLanga}
\label{sec:compiler}
\section{Budowanie drzewa AST}
Pierwszym etapem kompilacji jest parsowanie programu wejściowego do drzewa AST. Takie drzewo jest strukturą przechowującą informacje o składniowej
roli wyrażeń, które przetwarzać można na dalszych etapach kompilacji. Celem jest przetworzenie tekstu programu do postaci przypominającej derywację
gramatyki języka. Chociaż książkowa definicja drzewa AST mówi wyłącznie o składni, kompilator NianioLanga już na tym etapie dokonuje pewnej
podstawowej analizy semantycznej, gdyż wydzielenie tych czynności spowodowałoby dużą duplikację kodu związanego z czynnością obchodzenia drzewa.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{files/ast.png}
  \caption{Drzewo AST dla programu \texttt{if (1 == 2) \{return;\} else \{a++;\}}}
  \label{img:ast}
\end{figure}

Najpierw parser próbuje przeczytać listę importowanych modułów, gdyż zgodnie ze składnią języka musi ona zostać umieszczona na początku programu. Po
tym etapie następuje parsowanie listy funkcji. Każdy etap parsowania odbywa się poprzez analizę możliwie najdłuższej ilości tekstu, dopisanie błędów,
ustawienie wskaźnika następnej pozycji oraz innych pomocniczych wartości, które są przechowywane w zmiennej reprezentującej stan parsera, a na końcu
zwrócenie sparsowanej wartości. Nie ma znaczenia, co zwróci dana funkcja w razie błędu, gdyż wtedy kompilacja zostanie zatrzymana, a użytkownik
poinformowany o błędzie. W przypadku, gdy nie jest jasne, co należy sparsować (na przykład nie wiadomo, czy oczekujemy kolejnej deklaracji importu
modułu, czy definicji funkcji), próbuje się przeczytać różne wartości, aż któraś zostanie poprawnie sparsowana. Ważne jest, by różne możliwości
przetwarzać od największej do najmniejszej, jeżeli reprezentacja jedna może być początkiem drugiej, np. najpierw parsować należy operatory, a dopiero
potem wyrażenia, chyba że kolejność nie ma znaczenia. Przykładowo w wyrażeniu \emph{1 + 2 - 3} nie ma znaczenia, czy spróbujemy sparsować najpierw
operator dodawania, czy odejmowania, ale operator musi być sparsowany zanim sparsowana zostanie liczba. Innym przykładem jest \texttt{if}, po którym
może nastąpić \texttt{else} i najpierw należy spróbować sparsować blok \texttt{else} zanim przejdzie się do parsowania następnych komend.

Parsowanie funkcji odbywa się poprzez sparsowanie nagłówka, a następnie sparsowanie jej wnętrza jako jednej komendy. Przyjęte jest, że komenda może
być także listą komend, co parsuje się w sposób rekurencyjny. Ułatwia to parsowanie takich komend jak \texttt{for} czy \texttt{if}. Podejście to
umożliwia także tworzenie rekurencyjnych funkcji, z których każda odpowiedzialna jest za jeden element gramatyki języka. Funkcje te sposób działania
opierają na opisanym w poprzednim paragrafie schemacie.

Projekt nie wymagał znaczących zmian na etapie parsowania, dlatego nie zostaną one tutaj omówione. Jedynym wyjątkiem jest dodanie sprawdzania po
sparsowaniu funkcji, czy nie definiuje ona typu, a następnie wpisania tego typu do drzewa. Zostało to jednak wykonane przy użyciu dostępnych już
funkcji. Jest to wykonywane, by na dalszych etapach można było zapytać o dowolny definiowany typ, co ułatwia proces kompilacji. Sytuacja błędna nie
jest jednak obsługiwana, stanie się to dopiero podczas sprawdzania poprawności typów.
\section{Analiza semantyczna}
Drugim etapem kompilacji jest sprawdzenie poprawności typów. Wbrew nazwie etap ten nie ma na celu wyłącznie sprawdzenia, czy program jest poprawny
typowo -- do drzewa programu wpisywane są informacje o uzyskanych typach. Jest to konieczne, by móc dopasować typy NianioLanga do typów języka
wynikowego. Ponadto zachodzi tutaj analiza opisana w rozdziale \hyperref[sec:own_to_im]{Konwersja own $\rightarrow$ im}.

Na tym etapie sprawdza się, czy zaimportowane moduły faktycznie istnieją, czy definicje funkcji nie dublują się, oraz w końcu czy używane typy zgodne
są z oczekiwanymi. Trzeci element rozumiany jest dwojako. Po pierwsze, jeżeli dana zmienna ma zadeklarowany przez użytkownika typ, sprawdza się, czy
używana jest ona wyłącznie przez funkcje, które takiego typu oczekują.  Ze względu na nietrywialny system typów wydzielone są specjalne funkcje
sprawdzające czy i w jakim zakresie dwa typy są zgodne. Przykładowo jeżeli \texttt{im} używany jest w kontekście \texttt{hash}, to zgodnym typem jest
\texttt{hash}. Jeżeli zaś funkcja oczekuje \texttt{int} a podawany jest \texttt{array}, to zgłaszany jest błąd. W tym kontekście o typach myśleć można
jako o zbiorach możliwych wartości, na których wykonywane są operacje, przede wszystkim przecięcia.

Drugie rozumienie, które stosuje type checker, jest podobne do pierwszego, lecz w kontekście wnioskowania typów na podstawie wykonywanych na nich
operacji. Jeżeli dana zmienna inicjalizowana jest jako \texttt{int}, a następnie używana jako \texttt{hash}, to zgłaszany jest błąd. Warto zaznaczyć,
że operacje na typach wywnioskowanych są subtelniejsze, gdyż wiele typów jest konwertowalnych na \texttt{im} oraz w drugą stronę, przez co nie jest
możliwa całkowita, ścisła kontrola typów, ta ma miejsce dopiero w runtime. Ponownie, wydzielone są funkcje operujące na typach w analogii do zbiorów.

Samą budowę type checker ma podobną w pewnym sensie do parsera. W rekurencyjny sposób sprawdzamy, jakie typy mają poszczególne elementy drzewa oraz
czy są one poprawne. Tak jak w parserze zapisane jest, że operator \texttt{+} zawiera słowo kluczowe \texttt{+}, tak odpowiednia funkcja w type
checkerze wie, że argumenty tego operatora muszą mieć typ zwracany \texttt{int}. Ponownie pozwala to na podział funkcji w taki sposób, by każda
dotyczyła jednego, jasno wyszczególnionego elementu.
\section{Architektura nlasma}
nlasm to język stosowany w kompilatorze jako pomost pomiędzy NianioLangiem a językiem wyjściowym, gdyż bezpośrednia kompilacja NianioLanga do C, lub
też innego języka, może okazać się trudna, ponieważ używane struktury językowe znacząco od siebie odbiegają. Umożliwia to w łatwy sposób tworzenie
modułów kompilujących NianioLanga do różnych języków. Taka technika jest szeroko stosowana w świecie kompilatorów, jednym z najszerzej znanych
przykładów jest LLVM. Obecność autorskiego nlasma podyktowana jest przede wszystkim potrzebą języka pośredniego, który z jednej strony będzie możliwie
najprostszy, z drugiej w pewnym sensie zachowa strukturę programu wyjściowego.

Funkcje w nlasmie nie operują na zmiennych, lecz na rejestrach. Każdy rejestr ma swój unikalny w obrębie funkcji numer oraz typ. Także argumenty
funkcji są rejestrami. Wprowadzenie typów do nlasma było jednym z elementów projektu, gdyż o ile poprzednio wszystkie zmienne konwertowane były do
typu \texttt{im}, o tyle teraz przechować należy strukturę typów \texttt{own} czy \texttt{int}. Typy w nlasmie mają charakter wyłącznie informacyjny,
to znaczy nie mają żadnego znaczenia semantycznego.

Najważniejszą cechą nlasma jest nie drzewiasta, lecz liniowa struktura programu. Oznacza to, że argumentami wywołań mogą być wyłącznie rejestry, a nie
zmienne czy inne wywołania. W znacznym stopniu ułatwia to dalszą pracę kompilatora, przede wszystkim z powodu mniejszej liczby niuansów dotyczących na
przykład wartości zwracanych, przez co kod generatora języka docelowego może być znacznie prostszy. Ponadto generowanie kodu może odbywać się w sposób
liniowy, to znaczy każda komenda nlasma może mieć jednoznaczne, proste odzwierciedlenie w języku docelowym. Dzięki temu generator może dokonywać
analizy wyłącznie w zakresie charakterystycznym dla danego języka, na przykład do generatora C zostało wprowadzone sortowanie topologiczne deklaracji
typów.

Inną ważną cechą nlasma, wynikającą częściowo z poprzedniej, jest brak pętli. Translator NianioLanga do nlasm musi rozbić każdą pętlę na etykietę oraz
komendę \texttt{goto}. Takie podejście ułatwia tłumaczenie kodu na język docelowy, gdyż w różnych językach pętle działają w odrobinę inny sposób, zaś
\texttt{goto} tworzy nieskomplikowany, wspólny interfejs.

Ponadto nlasm zawiera polecenia służące do zarządzania pamięcią. Zakłada się, że język docelowy będzie korzystał ze zliczania referencji w celu
zwalniania pamięci. Aby nie pisać tej samej funkcjonalności oddzielnie dla wielu generatorów, nlasm zawiera polecenia mówiące o tym, że licznik
referencji danego rejestru (o ile jest on wskaźnikiem) należy zmniejszyć lub zwiększyć, co można w prosty sposób przełożyć na wywołania innych
języków. Oczywiście, jeżeli generator wybierze inną metodę zarządzania pamięcią, na przykład generując kod Javy, może te polecenia po prostu
zignorować. W przypadku generowania języka z manualnym zarządzaniem pamięcią, na przykład C, polecenia te są bardzo pomocne.


Przykładowe komendy nlasma:
\begin{itemize}
\item \texttt{if\_goto} -- sprawdza wartość w rejestrze. Jeżeli prawda, wykonuje skok pod etykietę
\item \texttt{clear} -- sygnalizuje, że wartość licznika referencji powinna spaść
\item \texttt{call} -- wywołuje funkcję o danej nazwie z danymi rejestrami jako argumentami, zapisuje wynik w danym rejestrze
\item \texttt{move} -- kopiuje wartość między dwoma rejestrami
\end{itemize}
\section{Translacja drzewa AST do nlasma}
\label{sec:translation}
\section{Generowanie kodu C na podstawie nlasma}
Jak zostało to omówione w poprzednim rozdziale, \texttt{nlasm} został zaprojektowany z myślą o ułatwieniu dalszej kompilacji. Wobec tego generowanie
kodu C jest bardzo proste.


Pierwszym etapem jest wygenerowanie kodu dla pliku nagłówkowego modułu. Zawiera on między innymi komentarz z informacją o tym, że dany plik został
wygenerowany automatycznie, instrukcje importujące nagłówki C biblioteki standardowej NianioLanga, czy też pewne instrukcje inicjujące, na przykład
ustawiające wartości stałych. Warto wspomnieć, że pliki \texttt{.c} i \texttt{.h} generowane są równolegle, gdyż pozwala to na przetwarzanie zgodnie z
kolejnością semantyczną, to znaczy na przykład generowanie wszelkich informacji o funkcji można oddelegować do raz wywoływanej procedury.


Drugim etapem jest wygenerowanie kodu odpowiedzialnego za obsługę typów, czyli ich deklaracje, definicje oraz potrzebne do obsługi funkcje. Przed
zmianami wprowadzonymi w ramach tego projektu etap ten nie występował, gdyż kod C używał ogólnego typu \texttt{ImmT}, który obsługiwać można
biblioteką standardową NianioLanga. Obecnie, ponieważ dla każdego typu \texttt{own} tworzony jest oddzielny typ na poziomie C, a funkcje go
obsługujące generowane są na poziomie NianioLanga, to podejście zostało zmienione. Ze względu na fakt, że definicje w NianioLangu nie muszą występować
w określonej kolejności, lecz w C już tak, konieczne jest sortowanie topologiczne, z uwzględnieniem możliwości wyodrębnionej deklaracji typu. Jest to
potrzebne do obsługi sytuacji, w której typ \texttt{A} potrzebuje w swojej definicji posługiwać się w pełni typem \texttt{B}, który z kolei posługuje
się wskaźnikiem na typ \texttt{A}.


Trzecim i ostatnim etapem jest wygenerowanie kodu odpowiedzialnego za same funkcje NianioLanga. Komendy nlasm w bardzo prosty sposób tłumaczą się na
język C, wobec czego generator na tym etapie wykonuje niewiele logiki, lecz jedynie pracę związaną z właściwie słownikowym przełożeniem instrukcji
mając jedynie na uwadze pewne szczegóły techniczne. Do tych szczegółów należy, pośród innych pomniejszych zadań, utworzenie wrapperów na funkcje tak,
by można było je wywoływać także mając daną tablicę argumentów, obsługa wskaźników i zarządzanie pamięcią oraz tworzenie komentarzy będących
informacją, której linii oryginalnego programu odpowiada dana seria instrukcji.


Po wykonaniu wszystkich trzech etapów pliki \texttt{.c} i \texttt{.h} danego modułu gotowe są do zapisania na dysku, a kompilator przechodzi do
tłumaczenia kolejnego modułu.
\section{Implementacja typów NianioLanga w C}
\label{sec:c_types_implementation}
Implementacja typów \texttt{ptd} opiera się na generycznym typie \texttt{ImmT}. Typ ten zdefiniowany jest jako \texttt{void*}, a w czasie wykonania
programu wskazuje na konkretne struktury danego obiektu. Pierwsze bajty każdego obiektu zawierają informacje o tym, jaki jest jego typ, oraz jaką
wartość ma licznik referencji. Jest to powszechny schemat symulowania programowania obiektowego w językach, które takowego nie wspierają, a takim
językiem jest C.


Operacje na danych definiowane są przez szereg funkcji dostępnych w bibliotece standardowej NianioLanga, dokompilowywanej do każdego programu, to
znaczy każdy moduł NianioLanga importuje jej nagłówki. Zawierają one podstawową funkcjonalność obsługi arytmetyki, struktur danych, operacji I/O.


Cała obsługa jest dość prosta i ma charakter możliwie najbardziej generyczny, wobec czego jest niezwykle niewydajna, w szczególności w kontekście
operacji na liczbach lub wartościach logicznych. Celem projektu była zmiana tej sytuacji i umożliwienie kompilatorowi C zastosowanie większej liczby
optymalizacji, co opisane jest w kolejnych rozdziałach.


\chapter{Zmiana systemu typów}
\section{Niezmienione cechy języka}
Z powodu dużego zakresu zmian przeprowadzonych w ramach niniejszej pracy, ważnym zadaniem było wyodrębnienie
podstawowych cech NianioLanga, które nie mogą ulec zmianie w wyniku jego rozwoju. Takimi cechami są:
\begin{itemize}
 \item Niezmienialność strukur -- wartość zmiennej nie może ulec zmianie pomiędzy dwiema kolejnymi jawnymi
 modyfikacjami
 \item Ścisła opcjonalność typów -- poprawny program po usunięciu wszystkich informacji o typach musi pozostać
 poprawny, a jego semantyka nie może się zmienić
\end{itemize}
Zachowanie powyższych cech zostało uznane za priorytet i miało wpływ na wiele podjętych podczas projektowania
decyzji.

\section{Rozdzielenie typu \texttt{ptd::sim}}
Najpoważniejszą zmianą, jaka zaszła w systemie typów w wynik niniejszego projektu było rozdzielenie
typu \texttt{ptd::sim} na typy \texttt{ptd::int} i \texttt{ptd::string} oraz rezygnacja ze wsparcia
języka dla liczba zmiennoprzecinkowych. Zmiana ta niesie ze sobą duże konsekwencje, przede wszystkim łamie
ona kompatybilność wsteczną, przez co duża część dotychczas poprawnych programów nie da się skompilować nową
wersją kompilatora. Decyzja o wprowadzeniu tej zmiany była podjęta z dwóch powodów:
\begin{itemize}
 \item Po pierwsze, wbrew początkowym założeniom języka, semantyka typów liczb całkowitych i łańcuchów znaków
 okazała się zupełnie inna. Pierwszy z nich jest wykorzystywany do operacji arytmetycznych i indeksowania tablic,
 podczas gdy drugi służy do indeksowania tablic asocjacyjnych. Obszary ich zastosowań są w dużej części rozłączne
 i brak kontroli rzutowania pomiędzy nimi prowadzi nieraz do błędnego modelowania dziedziny, co w efekcie
 może skutkować trudnymi do wykrycia błędami.
 \item Po drugie, narzut związany z przechowywaniem i sprawdzaniem typu zmiennej jest bardzo duży, zwłaszcza
 w przypadku liczb całkowitych. Rozdzielenie typu prostego na dwa typy umożliwiło generowanie bardziej
 wyspecjalizowanego kodu, co w efekcie znacząco przyspieszyło programy wynikowe.
\end{itemize}
Usunięcie obsługi liczb zmiennoprzecinkowych wynikało z analizy istniejącego kodu i było wykonane niejako
przy okacji. W trakcie analizy okazało się, że programy niemal nie korzystają w operacji na liczbach
zmiennoprzecinkowych, a ich uwzględnienie w języku znacząco komplikuje kod kompilatora. Jednocześnie,
z uwagi na łatwość integracji programów napisanych w NianioLangu z programami napisanymi w C, obsługa
liczb zmiennoprzecinkowych może zostać w razie potrzeby dodana w formie biblioteki.

\section{Typy \texttt{own}}
\subsection{Powody wprowadzenie typów \texttt{own}}
Drugą dużą zmianą wprowadzoną w systemie typów było dodanie całkiem nowej przestrzeni typów \texttt{own} obok
istniejącej przestrzeni \texttt{ptd}. Celem nowych typów miała być możliwość efektywnej kompilacji do
prostych konstrukcji języka C, co miało pozwolić na generowanie efektywniejszych programów wynikowych. 

\begin{wrapfigure}[19]{r}{.5\textwidth}
\begin{lstlisting}[caption={Przykład funkcji nianio},label={lst:nianio},aboveskip=-15pt]
def nianio::state() {
    return ptd::rec({
        num => ptd::int(),
        bool => ptd::bool(),
    });
}
def nianio::nianio(ref state : @nianio::state, cmd) {
    match (cmd) case :inc_num(var inc) {
        inc_num(ref state, inc);
    } case :neg_bool {
         state->bool = !state->bool;
    }
}
def inc_num(ref state : @nianio::state, inc) {
    state->num += inc;
}
\end{lstlisting}
\end{wrapfigure}
Szczególnym przypadkiem użycia dla nowych typów miał być opis stanu we wzorcu nianio.
Abstrahując od szczegółów, istotą wzorca nianio jest utrzymywanie stanu aplikacji w jednej zmiennej
i modyfikowanie go jedynie poprzez polecenia wysyłane do funkcji nianio (przykład znajduje się
na listingu \ref{lst:nianio}). W przypadku bardziej skompilowanych aplikacji o złożonym stanie,
zmienna \texttt{state} może być bardzo głęboko zagnieżdzona, a ponieważ modyfikacja liści jest najczęściej
występującą operacją we wzorcu nianio, więc czas dostępu do liści zagnieżdżonej
struktury ma duże znaczenie.

Inną często wykonywaną operacją jest przekazywanie stanu lub jego części przez wartość-wynik do innej funkcji,
żeby uczytelnić funkcję nianio przez wydzielenie z niej szczegółów implementacji. Z tego względu zmienna
przechowująca stan powinna móc być niskim kosztem przekazywana przez wartość-wynik. 

Typy \texttt{own} powinny więc spełniać powyższe wymagania, zachowując jednocześnie podstawowe cechy NianioLanga.

\subsection{Ograniczenia typów \texttt{own} wynikające z założeń NianioLanga}
Ponieważ nie było możliwe spełnienie wymagań stawianych przed typami \texttt{own} przy zachowaniu pełni
możliwości typów \texttt{ptd}, użycie typów \texttt{own} musiało zostać ograniczone w następujący sposób:
\begin{itemize}
 \item Zakaz kopiowania zmiennych -- dla zmiennych \texttt{a,b} typu \texttt{own} przypisanie
 \texttt{a = b} nie jest poprawną instrukcją i powinno zostać wyłapane podczas sprawdzania typów.
 Wynika to z faktu, że głębokie kopiowanie jest bardzo kosztowną operacją, a kopiowanie leniwe wymaga
 utrzymywania licznika referencji, którego zmienne typu \texttt{own} nie powinny mieć.
 Jednocześnie w podstawowym przypadku użycia -- we wzorcu nianio -- nie ma potrzeby kopiowania stanu.
 Istnieje w nim tylko jedna kopia zmiennej stanowej, przekazywana do kolejnych funkcji i modyfikowana w miejscu.
 \item Zakaz wielokrotnego przekazywania argumentów przez \texttt{ref} -- dla zmiennej \texttt{a} typu
 \texttt{own} wywołania \texttt{f(ref a, ref a)} oraz \texttt{f(ref a, ref a->b)} nie są poprawnymi wyrażeniami.
 Argumenty \texttt{ref} to argumenty przekazywane przez wartość-wynik.
 Semantyka takiego przekazywania argumentów wygląda tak, że przed wywołaniem funkcji przekazywana zmienna
 est kopiowana do argumentu, a po zakończeniu wywołania następuje kopiowanie z powrotem.
 Zapobiega to naruszeniu niezmienialności struktur,
 które miałoby miejsce gdyby argumenty były przekazywane przez referencję (listing \ref{lst:ref}).
 Jednak, w przypadku przekazywania jednego argumentu wielokrotnie implementacja takiej semantyki wymaga
 faktycznego skopiowania zmiennej do argumentów, co jest zabronione w przypadku zmiennych typu \texttt{own}.
\begin{lstlisting}[caption={Naruszenie niezmienialności wartości w C},label={lst:ref}]
int main() [
	var a = 1;
	f(&a, &a);
}
def f(int *a, int *b) {
	printf("%d\n", a); // 1
	*b++;
	printf("%d\n", a); // 2
}
\end{lstlisting}
 \item Podobnie, zabronione są wszelkie operacje, w wyniku których mogłoby dojść do uzyskania dostępu
 do jednej wartości z dwóch różnych zmiennych jednocześnie. W sytacjach tego wymagających możliwe jest tymczasowe
 przeniesienie własności z jednej zmiennej na drugą. Taka sytuacja występuje na przykład podczas iteracji
 tablicy asocjacyjnej pętlą \texttt{forh} (listing \ref{lst:forh}).
\begin{lstlisting}[caption={Odwołanie do zmiennej, która utraciła własność},label={lst:forh}]
var h : own::hash(ptd::int());
forh var key, ref value (h) {
	value++; # Ok
	h{key}++; # Error
}
\end{lstlisting}
\end{itemize}


\chapter{Rozszerzenie nlasma}
\section{Przekazywanie informacji o typach z drzewa AST}
Pierwszą zmianą, jaka została wprowadzona w nlasmie było dodanie informacji o typach do jego rejestrów.
Było to konieczne, aby umożliwić generowanie poprawnych typów w kodzie C, ponieważ generator kodu wynikowego
nie ma już dostępu do drzewa AST -- cała potrzebna mu informacja musi być zawarta w kodzie pośrednim.
W związku z tym do każdego rejestru nlasma została dodana informacja o jego typie.
W trakcie tworzenia wynikowego kodu C generator bierze pod uwagę tę informację i dobiera typ zmiennych języka C
w zależności od typów rejestrów.

Typy rejestrów zostały uproszczone w stosunku do typów obliczanych podczas etapu sprawdzania typów.
Możliwe typy rejestrów to:
\begin{itemize}
 \item \texttt{im} -- dla wszystkich zmiennych typu \texttt{im}. Przed wprowadzeniem typowanych rejestrów
 każdy rejestr był tego typu.
 \item \texttt{int} -- dla zmiennych całkowitoliczbowych.
 \item \texttt{string} -- dla łańcuchów znaków
 \item \texttt{bool} -- dla wartości logicznych
 \item \texttt{rec} -- dla rekordów typu \texttt{own}
 \item \texttt{arr} -- dla tablic typu \texttt{own}
 \item \texttt{variant} -- dla wariantów typu \texttt{own}
 \item \texttt{hash} -- dla zmiennych typu \texttt{own::hash}
\end{itemize}


Ponieważ w wersji nlasma sprzed wprowadzenia typów \texttt{own} wszystkie rejestry były jednego typu, więc
dodanie rejestrów typowanych wymagało zdefiniowania zachowania typów na poziomie nlasma.
Pierwszym elementem, który należało uwzglednić była kwestia wykonywania operacji na rejestrach różnych typów.
W celu uproszczenia semantyki nlasma została podjęta decyzja, żeby jedyną instrukcją, która może powodować
rzutowanie pomiędzy różnymi typami była instrukcja \texttt{move}.
Wszystkie inne instrukcje mają ściśle określone typy argumentów i jeśli generator trafi na instrukcję z argumentem
o niepoprawnym typie, zgłosi błąd. Drugą ważną kwestią była decyzja co do przeniesienia opcjonalności typów
na poziom nlasma. Ponieważ w kompilatorze istnieje możliwość bezpośredniej interpretacji nlasma bez kompilacji,
opcjonalność typów na poziomie nlasma okazała się koniecznością, którą należało uwzględnić podczas projektowania
rozszerzenia nlasma o rejestry typowane.

Przykłady poprawnego i niepoprawnego kodu nlasm znajdują się na listingach
\ref{lst:reg_types_1} i \ref{lst:reg_types_2}.
Polecenie \texttt{get\_frm\_idx}, które służy do dostępu do elementu tablicy pod konkretnym indeksem, oczekuje,
że rejestr, w którym przechowywany jest indeks będzie typu \texttt{int}.
Jeśli rejestr z indeksem jest innego typu, należy wcześniej wykonać rzutowanie.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[caption={Niepoprawny typowo kod nlasm},label={lst:reg_types_1}]
[
    :get_frm_idx({
        dest => {
            reg_no => 2,
            type => :im,
        },
        idx => {
            reg_no => 1,
            type => :im,
        },
        src => {
            reg_no => 0,
            type => :im,
        },
    }),
]
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[caption={Poprawny kod nlasm z rzutowaniem},label={lst:reg_types_2}]
[
    :move({
        dest => {
            reg_no => 3,
            type => :int,
        },
        src => {
            reg_no => 1,
            type => :im,
        },
    }),
    :get_frm_idx({
        dest => {
            reg_no => 2,
            type => :im,
        },
        idx => {
            reg_no => 3,
            type => :int,
        },
        src => {
            reg_no => 0,
            type => :im,
        },
    }),
]
\end{lstlisting}
\end{minipage}

Należy jednak zaznaczyć, że opisane wyżej konwersje przy użyciu polecenia \texttt{move} dotyczą jedynie
rzutowania pomiędzy typem \texttt{im} a typami \texttt{int}, \texttt{string} i \texttt{bool}.
Decyzja taka została podjęta, ponieważ konwersje te są stosunkowo tanie i bardzo szeroko wykorzystywane
Inne konwersje muszą być obsłużone na etapie sprawdzania typów.

Przykład programu, dla którego zostanie wygenerowane rzutowanie podobne do przedstawionego wyżej
znajduje się na listingu \ref{lst:reg_im}.
Ponieważ wartość \texttt{x->i} może być zarówno napisem, jak i liczbą całkowitą, więc jest typu \texttt{im},
a zatem także rejestr, w którym jest przechowywana musi być typu \texttt{im}.
Jednak, jak zostało wspomniane wyżej, rejestr użyty do indeksowania tablicy musi być typu \texttt{int}.
Wymusza to wprowadzenie rejestru pomocniczego tego typu i użycie rzutowania przy pomocy polecenia \texttt{move},
analogicznie jak na listingu \ref{lst:reg_types_2}.
\begin{minipage}{\linewidth}
\begin{lstlisting}[caption={Indeksowanie tablicy zmienną typu \texttt{im}},label={lst:reg_im}]
var x;
var arr = [1,2,3];
x->i = 'a';
x->i = 1;
arr[x->i];
\end{lstlisting}
\end{minipage}

\section{Tłumaczenie dostępów do zmiennych na kod nlasm}
Jedną z głównych zalet nlasma jest prostota jego pojedynczych instrukcji, dzięki czemu większość
pracy związanej z generowaniem kodu wynikowego można wykonać wspólnie dla wszystkich językow docelowych.
Na przykład, jeśli zmienne \texttt{a} i \texttt{b} są typu \texttt{im}, to instrukcja NianioLanga
\texttt{a->b[0] = 1} zostanie przetłumaczona do ciągu poleceń nlasma
\texttt{get\_hash\_val}, \texttt{get\_frm\_idx}, \texttt{set\_at\_index}, \texttt{set\_hash\_val} zgodnie
z opisem z rozdziału \nameref{sec:translation}.

Niestety to podejście nie jest odpowiednie w przypadku dostępów do zmiennych typu own.
Semantyka poleceń \texttt{get\_hash\_val} i \texttt{get\_frm\_idx} jest taka, że wartość pobierana
z hasha lub tablicy jest leniwie kopiowana do rejestru docelowego, dzięki czemu także na poziomie nlasma
nie występuje pojęcie referencji, a niezmienialność wartości jest zachowana.
Leniwe kopiowanie zmiennych typu \texttt{own} nie jest możliwe, więc należało wybrać inny sposób na
tłumaczenie dostępów do zmiennych \texttt{own} w efektywny sposób.

Ponieważ celem typów \texttt{own} jest ich efektywna kompilacja do języka C, więc potrzebne było
wprowadzenie do nlasma w jakiś sposób pojęcia referencji w sposób współgrający z jego dotychczasową filozofią.
W tym celu zostały wprowadzone polecenia \texttt{use\_field}, \texttt{use\_index}, \texttt{use\_hash\_index} oraz
\texttt{use\_variant}, umożliwiające pobranie referencji do elementu z wnętrza odpowiednio rekordu, tablicy, hasha
i wariantu, oraz odpowiadające im polecenia \texttt{release\_*}.

Polecenia \texttt{use\_*} oprócz pobrania referencji powodują także przeniesienie własności zmiennej z rejestru
źródłowego na rejestr docelowy, a polecenia \texttt{release\_*} służą do zwrócenia własności po zakończeniu
operacji. Kod nlasm, w którym następuje odwołanie do rejestru, który nie ma w tym momencie własności zmiennej,
jest uznawany za niepoprawny. Dzięki takiemu rozwiązaniu w poprawnym kodzie nlasma nie ma możliwości wystąpienia
współbieżnego dostępu do wartości poprzez różne referencje do niej.

Dzięki dodaniu do nlasma pojęcia referencji znacząco zmniejszył się koszt modyfikacji elementów w głęboko
zagnieżdżonych strukturach. W odróżnieniu od implementacji dla typów \texttt{im}, zmienne typu \texttt{own}
są modyfikowane w miejscu -- podczas modyfikacji nie są tworzone żadne dodatkowe struktury, a jedynie
kolejne rejestry wskaźnikowe. Rozwiązanie dla typów \texttt{im} przypomina podejście funkcyjne:
najpierw dany element jest krok po kroku wyjmowany poprzez odpakowywanie kolejnych struktur
(polecenia \texttt{get\_*}), następnie jest on modyfikowany, a na końcu jest pakowany z powrotem (polecenia
\texttt{set\_*}). W odróżnieniu od tego, rozwiązanie dla typów \texttt{own} jest podobne do podejścia
imperatywnego: poprzez ciąg poleceń \texttt{use\_*} obliczana jest referencja do modyfikowanego elementu, a
następnie element ten jest modyfikowany poprzez odwołanie do tej referencji.
Następujący potem ciąg poleceń \texttt{release\_*}
spełnia jedynie funkcję wnioskowania o poprawności kodu nlasm i nie powoduje narzutu w czasie wykonania programu.
Jednocześnie zachowana jest możliwość zignorowania typów rejestrów i traktowania wszystkich jako rejestry
typu \texttt{im}.

Przykład modyfikacji zmiennej typu \texttt{own} przetłumaczonej na nowe polecenia nlasma znajduje się na listingu 
\ref{lst:own_access_nlasm}.

\noindent\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[caption={Modyfikacja zmiennej typu \texttt{own} w NianioLangu}]
# a : own::rec({
#    b => own::arr(ptd::int()),
# })

a->b[0] = 1;
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}[t]{.45\textwidth}
\begin{lstlisting}[caption={Modyfikacja zmiennej typu \texttt{own} przetłumaczona na nlasm},label={lst:own_access_nlasm}]
[
    :use_field({
        old_owner => {
            reg_no => 0, type => :rec,
        },
        new_owner => {
            reg_no => 2, type => :arr,
        },
        field_name => "b",
    }),
    :load_const({
        dest => {
            reg_no => 3, type => :int,
        },
        val => 0,
    }),
    :use_index({
        index => {
            reg_no => 3, type => :int,
        },
        new_owner => {
            reg_no => 4, type => :int,
        },
        old_owner => {
            reg_no => 2, type => :rec,
        },
    }),
    :load_const({
        dest => {
            reg_no => 4, type => :int,
        },
        val => 1,
    }),
    :release_index({
        current_owner => {
            reg_no => 4, type => :int,
        },
        index => {
            reg_no => 3, type => :int,
        },
    }),
    :release_field({
        current_owner => {
            reg_no => 2, type => :arr,
        },
        field_name => "b",
    }),
]
\end{lstlisting}
\end{minipage}

\section{Statyczne sprawdzanie poprawności}
Decyzja o wprowadzeniu pojęcia referencji i własności zmiennej do nlasma wiązała się z ryzykiem generowania
kodu nlasm, którego semantyka nie odpowiada semantyce zmiennych NianioLanga.
Może to prowadzić do trudnych do wykrycia błędów oraz naruszeń bezpieczeństwa, które przed wprowadzeniem
typów \texttt{own} było zagwarantowane na poziomie składni nlasma.

Aby nie tracić zupełnie gwarancji dawanych przez nlasm można dodać do kompilatora moduł
sprawdzający poprawność wygenerowanego kodu nlasma. Jest to możliwe dzięki odpowiedniemu zdefiniowaniu poleceń
\texttt{use\_*} i \texttt{release\_*}. Z każdym poleceniem nlasma można powiązać listę niedostępnych
rejestrów, czyli rejestrów które na pewnej ścieżce wykonania mogą nie posiadać własności powiązanej zmiennej.
Jeśli polecenie próbuje odczytać lub zmodyfikować któryś z niedostępnych rejestrów, powinien zostać zgłoszony
błąd.

Generowanie listy niedostępnych rejestrów dla każdego polecenia może zostać wykonane przez kilkukrotne
liniowe przejście po liście poleceń z uwzględnieniem możliwych skoków.
Innym możliwym podejściem jest zapisywanie listy niedostępnych rejestrów bezpośrednio
w kodzie nlasma, tak aby zawierał on łatwy do sprawdzenia dowód poprawności.
Zagadnienia dotyczące statycznego sprawdzania poprawności nlasma pozostają jednak poza zakresem niniejszej
pracy.

\section{Pozostałe nowe polecenia}
Oprócz poleceń pozwalających na dostęp do zmiennych typu \texttt{own} do nlasma zostały dodane także inne 
polecenia, które wcześniej były realizowane jako wywołania funkcji bibliotecznych.
Są to polecenia \texttt{array\_len} i \texttt{array\_push}, pozwalające na obsługę tablic typu \texttt{own}
oraz rodzina poleceń \texttt{hash\_*\_iter} pozwalających na implementację pętli \texttt{forh},
służącej do iterowania po elementach hasha.

Każde z powyższych poleceń było w poprzedniej wersji kompilatora generowane jako polecenie \texttt{call},
którego argumentem była nazwa konkretnej funkcji bibliotecznej realizującej dane zadanie (na przykład
\texttt{c\_rt\_lib0array\_len} z bilioteki \texttt{c\_rt\_lib}). Podejście to wymagało zmiany ze względu
na to, że w przypadku typów \texttt{own} dla każdego typu generowane są osobne funkcje o unikalnych
nazwach tworzonych przez generator i nieznanych w momencie tłumaczenia drzewa AST do kodu nlasma.
Dzięki dodaniu nowych poleceń możliwe było zaimplementowanie generowania nazw tych funkcji w momencie
generowania kodu C, kiedy ich nazwy sa już znane.

\chapter{Nowe implementacje typów}
\section{Typy proste}
Pierwszą zmianą, jaka została wprowadzona w generatorze kodu, było uproszczenie,
tam gdzie to możliwe, kodu generowanego dla operacji na typach prostych.
Rozdzielenie typu \texttt{ptd::sim} na osobne typy dla liczb naturalnych,
łańcuchów znaków i wartości logicznych umożliwiło bardziej uważny dobór instrukcji języka C,
co przełożyło się na wydajniejszy kod wynikowy.

\subsection{Liczby całkowite}
Wartości typu \texttt{ptd::int}, czyli liczby całkowite, w wyniku wprowadzonych zmian są kompilowane
do zmiennych języka C o typie \texttt{int}. Zapewnia to dobrą wydajność operacji artytmetycznych,
które na obecnych procesorach wykonują się w niewielkiej liczbie cykli. Użycie typu języka C
dedykowanego dla liczb całkowitych umożliwia też kompilatorowi \texttt{gcc} lepszą optymalizację
na dalszym etapie kompilacji (na przykład umożliwia ewaluację stałych w czasie kompilacji).
\subsection{Łańcuchów znaków}
Implementacja łańcuchów znaków nie została zmieniona w stosunku do istniejącej wcześniej.
Decyzja ta była spowodowana efektywnością już istniejącej implementacji -- łańcuchy znaków
są kompilowane to tablic typu \texttt{char[]}, opakowanych w struktury zawierające
rozmiar i pojemność tablicy. Dostęp takich zmiennych odbywa się poprzez specjalne funkcje,
zapewniające utrzymanie poprawnego stanu całej struktury. Jest to minimalny narzut potrzebny żeby
zachować bezpieczeństwo języka i uchronić programistę przed błedami, takimi jak przepełnienie bufora.
Z tego względu została podjęta decyzja o niepowielaniu istniejącej implementacji i wykorzystaniu
tej już istniejącej.
\subsection{Wartości logiczne}
Jak zostało to opisane w rozdziale \hyperref[sec:c_types_implementation]{Implementacja typów NianioLanga w C}, dotychczasowa implementacja wartości logicznych opierała się na dwuwartościowych
języka NianioLang. Z uwagi na to, że warianty są dość wysokopoziomowym mechanizmem, bez
bezpośredniego odzwierciedlenia w języku C, kod wynikowy generowany dla wartości logicznych nie był
efektywny.

W wyniku przeprowadzonych zmian wartości logiczne są kompilowane do zmiennych typu \texttt{bool},
zdefiniowanego w pliku \texttt{stdbool.h} biblioteki standardowej języka C.
Podobnie, jak w przypadku liczb całkowitych zapewnia to dobrą wydajność operacji logicznych
ze względu na bezpośrednie wsparcie procesora i kompilatora \texttt{gcc}.

\subsection{Ograniczenia kompilacji typów prostych}
\begin{wrapfigure}[10]{r}{.4\textwidth}
\begin{lstlisting}[caption={Zmienna kompilowana do typu \texttt{ImmT}},label={lst:immt_variable},aboveskip=-15pt]
var x;
x = 'a';
x = 1;
x++;
\end{lstlisting}
\end{wrapfigure}
Z uwagi na leżące u podstaw języka założenie o opcjonalności typów nie było możliwe
zagwarantowanie efektywnej kompilacji typów prostych w każdych warunkach.
Na przykład kod przedstawiony na listingu \ref{lst:immt_variable} zostanie skompilowany do ciągu operacji na mniej efektywnym typie
\texttt{ImmT}. Spowodowane jest to zmianą typu zmiennej \texttt{x} w trakcie działania programu,
przez co nie można jej przypisać żadnego z typów prostych.

\section{Typy złożone}
Dla każdego typu złożonego z przestrzeni \texttt{ptd} został utworzony odpowiadający mu typ
w przestrzeni \texttt{own}. Dla każdego konkretnego typu, zdefiniowanego przez użytkownika
i korzystającego z typów \texttt{own}, w kodzie wynikowym w C generowane są oddzielne definicje
typu oraz funkcji na nim operujących. Jest to główna różnica w stosunku do typów z przestrzeni
\texttt{ptd}, dla których zdefiniowany był jeden polimorficzny typ \texttt{ImmT}.
Takie podejście umożliwia bardziej efektywną alokację pamięci przez kompilator (ponieważ rozmiar
wielu struktur jest z góry znany) oraz zapewnia statyczną kontrolę typów także przez kompilator
\texttt{gcc}, pozwalając wykrywać wiele błędów w kodzie generowanym przez kompilator
NianioLanga już na etapie kompilacji.
\subsection{Tablice}
Definicje typów \texttt{own::arr} kompilowane są do struktury zawierającej rozmiar tablicy, jej
maksymalną pojemność i wskaźnik na jej pierwszy element. Do programu wynikowego
dodawane są również funkcje,
pozwalające na dodawanie nowego elementu na koniec tablicy, pobieranie wskaźnika do elementu
o danych indeksie oraz na pobieranie rozmiaru tablicy. Operacja dodawania elementu na koniec tablicy
została zaimplementowana w sposób opisany na przykład w książce
\textit{Wprowadzenie do algorytmów} \cite{cormen}: po przekroczeniu połowy dostępnego miejsca
tablica zostaje powiększona dwukrotnie. Dzięki takiej implementacji operacja
ta działa w zamortyzowanym czasie stałym.

Dla każdego typu tablicowego zostaje także wygenerowana funkcja zwalniająca pamięć zajmowaną
przez tablicę. Wywołuje ona odpowiednią funkcję zwalniającą pamięć dla każdego elementu,
a następnie zwalnia pamięć, w której znajdowały się elementy tablicy.
\subsection{Rekordy}
Rekord był typem, od którego zaczęła się idea typów \texttt{own}. Było tak, ponieważ rekordy jako jedyny
typ złożony posiadają bezpośrednie odzwierciedlenie w typach języka C, czyli \texttt{struct}.
Każda definicja typu rekordowego z rodziny \texttt{own} jest kompilowana do definicji typu \texttt{struct}
w języku C. Każde pole rekordu odpowiada osobnemu polu struktury o odpowiadającym typie i nazwie.
Istotne jest, że typy pola struktury są wartościami, a nie wskaźnikami, co pozwoliło uniknąć niepotrzebnych
dynamicznych alokacji pamięci i umożliwiło alokację struktur w całości na stosie.

Dzięki takiej reprezentacji rekordów w pamięci możliwe było skompilowanie dostępów do pól rekordu wykorzystując
operatory \texttt{.} i \texttt{->} języka C, co jest znacznym usprawnieniem w stosunku do poprzedniej implementacji,
używającej w tym celu tablic haszujących.
\subsection{Typy wariantowe}
\begin{wrapfigure}[12]{r}{.4\textwidth}
\begin{lstlisting}[caption={Rekurencyjna definicja struktury drzewiastej},label={lst:tree},aboveskip=-15pt]
def tree::node() {
    return own::var({
        node => own::rec({
            left => @tree::node,
            right => @tree::node,
            value => ptd::int(),
		}),
        leaf => ptd::none(),
	});
})
\end{lstlisting}
\end{wrapfigure}
Typ wariantowy, inaczej nazywany tagowaną unią (\textit{tagged union}), jako jedyny pozwala wprowadzić
w NianioLangu typy rekurencyjne. O ile rekurencyjne rekordy są niedozwolone ze względu na niemożliwość ich
pełnej inicjalizacji, o tyle warianty pozwalają przerwać rekurencję na pewnym poziomie, tym samym unikając
problemu nieskończonych struktur (przykład takiej definicji znajduje się na listingu \ref{lst:tree}).
Ta cecha wymusiła przechowywanie danych w wariancie wyłącznie jako wskaźniki na właściwe obiekty.
W celu oszczędności pamięci przy zachowaniu sprawdzania poprawności typów przez kompilator C definicje typów
wariantowych kompilowane są do rekordów, zawierających całkowitoliczbowe pole określające, który z wariantów
jest przechowywany i unię wskaźników na typy poszczególnych możliwych wartości.
Zastosowanie liczby całkowitej jako wartości określający konkretny wariant umożliwiło bardziej efektywne
rozpoznawanie wariantu i skróciło czas wykonania instrukcji \texttt{match} (poprzednia implementacja do
odróżniania wariantów używała nazwy wariantu z kodu, co wymuszało kosztowne porównywanie łańcuchów znaków
w trakcie działania programu).
\subsection{Tablice asocjacyjne}
Tablice asocjacyjne, nazywane w NianioLangu hashami, to struktury podobne do tablic, ale indeksowane dowolnymi
ciągami znaków. Są one zdecydowanie bardziej wysokopoziomowe od wcześniej opisanych struktur i nie mają
oczywistego odpowiednika w języku C, więc zysk ze skompilowania ich jako typy \texttt{own} nie jest istotny.
Niemniej jednak zostały one uwzględnione, ponieważ ze względu na ograniczenia typów \texttt{own} nie mogą
one być zawarte w typach \texttt{ptd}, więc dodanie typu \texttt{own::hash} było jedynym sposobem na efektywną
kompilację struktur zawartych wewnątrz tablic asocjacyjnych.

Sama implementacja dostępów do elementów tablic asocjacyjnych nie zmieniła się znacząco w porównaniu
do poprzedniej implementacji. Główną różnicą jest generowanie osobnej funkcji dostępu dla każdego zdefiniowanego
typu, co zapewnia zachowanie typowania na poziomie C i umożliwia pominięcie utrzymywania licznika referencji
tam, gdzie jest on zbędny.

\section{Konwersja own $\rightarrow$ im}
\label{sec:own_to_im}
Konwersja typów \texttt{own} na typ \texttt{ptd::im}, który jest uniwersalną reprezentacją typów z przestrzeni \texttt{ptd},
jest naturalną potrzebą języka. Obiekty o typie z przestrzeni nazw \texttt{own} są ograniczone w zasięgu,
więc chcąc zwrócić wartość takiego obiektu lub przekazać do funkcji, która przyjmuje argumenty z przestrzeni
nazw \texttt{ptd}, musimy go przekonwertować.

Analiza przypadków użycia konwersji pokazała, że konwersja z typów \texttt{ptd} na typy \texttt{own} nie ma 
szczególnego zastosowania i nie musi być przez język obsługiwana, przede wszystkim dlatego,
że tworzenie typu statycznego z typu dynamicznego w pewnym sensie mija się z celem korzystania z typów statycznych w ogóle,
gdyż narzut wydajnościowy związany z tworzeniem obiektów typu \texttt{ptd::im}, a potem konstruowanie z nich obiektów typu \texttt{own} byłby zbyt duży.
W drugą stronę zaś konwersja pozwala na łączenie nowego kodu ze starym oraz odejście od statycznego typowania w chwili,
gdy chcemy korzystać z funkcji obsługujących wiele typów, na przykład implementując kontenery.

Istnieje wiele sposobów na implementację konwersji. Pierwszy z nich polega na zapisaniu w bibliotece C języka ogólnej funkcji konwertujących obiekty \texttt{own} na obiekty \texttt{ptd::im}.
Podejście to ma jednak wiele wad, przede wszystkim trudność implementacji, dużą podatność na błędy oraz wątpliwą przenośność rozwiązania.
Szczególnie trzeci argument jest ważny, gdyż dalsze kierunki rozwoju języka prawdopodobnie przewidują przywrócenie do kompilatora możliwości kompilowania na inne języki niż C.

Drugi sposób polega na stworzeniu funkcji-wydmuszki przyjmującej w argumencie obiekt \texttt{own}, która w trakcie kompilacji podmieniana jest na właściwy kod dokonujący konstrukcji obiektu \texttt{ptd::im}.
Duże problemy stwarza jednak implementacja dla typów rekurencyjnych (warianty) oraz puchnięcie kodu wynikowego, zawierającego bardzo podobne, potencjalnie bardzo długie sekcje.

Trzeci sposób, który został zrealizowany, jest niejako połączeniem dwóch poprzednich -- dla każdego typu
nazwanego oraz dla każdego typu, który korzysta z funkcji-wydmuszki, generowana jest funkcja,
podpinana w miejsce wydmuszki. Można to w pewnym sensie porównać do generowania szablonów w C++, aczkolwiek ten system jest bardziej wyspecjalizowany.

Pierwszym elementem rozwiązania jest zebranie informacji o tym, jakie funkcje należy wygenerować,
co przeprowadzane jest w dwóch miejscach.
Ze względu na możliwość używania typów z innych modułów, niż w danym momencie wykonywany, każdy moduł udostępniać musi komplet funkcji do rzutowania typów, które definiuje.
Najpierw, po załadowaniu drzewa AST modułu do type checkera, dokonywany jest obchód po funkcjach definiujących typy sprawdzający, czy nie definiują one typów \texttt{own}.
Miejsce to zostało wybrane, gdyż jest to pierwsze miejsce, gdzie pojawia się konkretna wiedza o typach zmiennych.
Następnie, podczas sprawdzania typów funkcji, za każdym razem, gdy napotykana jest funkcja-wydmuszka, zapamiętywany jest typ argumentu, z jakim została ona wywołana.
Typy te są również rekurencyjnie sprawdzane, czy nie zawierają innych typów \texttt{own}, do których także należy stworzyć stosowne funkcje.

Drugim elementem rozwiązania jest generowanie kodu. Tworzona jest zmienna tekstowa, która następnie wypełniana jest instrukcjami tworzącymi obiekt \texttt{ptd::im}.
Ponieważ typy mogą być zagnieżdżone, w razie potrzeb wywołują one inne funkcje konwertujące wewnętrzne obiekty \texttt{own} na \texttt{im}.
Warto podkreślić, że w przypadku typów \texttt{own::rec} oraz \texttt{own::var} funkcje rzutujące nawet podobne typy są istotnie różne.
Rzutując rekordy należy explicite przypisać wszystkie pola, nie jest możliwe zrobienie tego w ogólny sposób pętlą, zaś rzutując warianty
wykonać należy pełną instrukcję \texttt{match}.

Trzecim elementem jest wstrzyknięcie kodu. Sprawdzanie typów rozdzielone jest od wpisywania ich do drzewa AST
i w trakcie tego wpisywania podmieniane są wywołania funkcji-wydmuszki na wywołania
odpowiedniej funkcji o automatycznie generowanej nazwie. Generowana nazwa jest tworzona na postawie nazwy dla typów nazwanych, oraz na podstawie zawartości
dla typów anonimowych -- uzyskujemy w ten sposób deduplikację kodu, generując w kodzie wynikowym C tylko jedną funkcję dla danego typu.

Pozostaje jeszcze problem dodania definicji nowych funkcji do drzewa AST. Wygenerowany kod jest parsowany do samodzielnego modułu,
który przechodzi przez type checker w sposób podobny do normalnego kodu. Po przejściu przez type checker moduły są łączone w jeden. Gdy cały program przejdzie przez type checker
dalsza kompilacja przebiega tak, jak gdyby użytkownik sam utworzył sztucznie wygenerowane funkcje.

Generując funkcje, a z nich drzewo AST, można mieć wątpliwości, czy nie lepiej byłoby od razu tworzyć gotowe do podczepienia poddrzewa, czy nawet kod wynikowy w C,
zamiast marnować czas procesora na przejście przez parser i type checker. 
Zautomatyzowane tworzenie drzewa AST daje gwarancję, że w przypadku dalszej ewolucji kompilatora nie trzeba będzie pamiętać o tym,
aby każda zmiana miała odzwierciedlenie w module generowania kodu. Ze względu na dużą dynamikę rozwoju języka jest to cecha pożądana.
Ponadto zmniejszanie czasu kompilacji programów nie było głównym celem projektu, a analiza przypadków użycia wykazała, że narzut czasowy jest w pełni akceptowalny.

\chapter{Efekty optymalizacji i wnioski}
\section{Porównanie czasu wykonania programów}

\chapter{Wkład poszczególnych członków zespołu}
\begin{itemize}
  \item[] \textbf{Michał Borkowski}
  \begin{itemize}
   \item Implementacja konwersji typów \texttt{own} na typy \texttt{im}
   \item Implementacja skryptu do testowania zmian wydajności w czasie trwania projektu
   \item Opis konwersji typów \texttt{own} na typy \texttt{im} w pracy licencjackiej
  \end{itemize}

  \item[] \textbf{Jakub Bujak}
  \begin{itemize}
   \item Implementacja generowania typów języka C dla zdefiniowanych w NianioLangu typów \texttt{own}
   \item Generowanie funkcji umożliwiających dostęp do zmiennych typu \texttt{own} i ich modyfikację
   \item Opis zmian w systemie typów w pracy licencjackiej
  \end{itemize}

  \item[] \textbf{Marian Dziubiak}
  \begin{itemize}
   \item Implementacja uzupełniania drzewa AST typami wywnioskowanymi w procesie kontroli typów
   \item Modyfikacja typów funkcji bibliotecznyh w związku z rozdzieleniem typu \texttt{ptd::sim}
   \item Opis w pracy licencjackiej metodyki pracy używanej podzcas projektu
  \end{itemize}

  \item[] \textbf{Marek Puzyna}
  \begin{itemize}
   \item Implementacja generowania definicji funkcji zwalnianjących pamięć zajmowaną przez typy \texttt{own}
   \item Implementacja generowania wywołań funkcji zwalniających pamięć dla zmiennnych typu \texttt{own} wychodzących
     z zasięgu
   \item Opis w pracy licencjackiej translacji drzewa AST do kodu nlasma
  \end{itemize}


\end{itemize}


\appendix

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem{wzorzec_nianio} \href{https://www.mimuw.edu.pl/~chrzaszc/BPJ20067/nianio.pdf}{LK, \textit{Wzorzec ,,Nianio'' przykład} - 2006}.
\bibitem{github_repo_nianiolang_original} \href{https://github.com/nianiolang/nl}{NianioLang Compiler - GitHub}
\bibitem{cormen} Thomas H. Cormen, Charles E. Leiserson, Ron Rivest, Clifford Stein \textit{Wprowadzenie do algorytmów}, Wydawnictwo Naukowe PWN (2013)


\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
