%
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[licencjacka]{pracamgr}

\usepackage{hyperref}

% Dane magistrantów:
\autori{Michał Borkowski}{370727}
\autorii{Jakub Bujak}{370737}
\autoriii{Marian Dziubiak}{370784}
\autoriv{Marek Puzyna}{371359}

\title{Kompilacja NianioLanga do efektywnych struktur języka C}


%\tytulang{An implementation of a difference blabalizer based on the theory of $\sigma$ -- $\rho$ phetors}

%kierunek:
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{mgr. Radosława Bartosiaka\\
  Instytut Informatyki\\
  }

% miesiąc i~rok:
\date{Maj 2018}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{
%11.0 Matematyka, Informatyka:\\
%11.1 Matematyka\\
%11.2 Statystyka\\
11.3 Informatyka\\
%11.4 Sztuczna inteligencja\\
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.3. Programming languages\\
  D.3.3. Language contructs and features}

% Słowa kluczowe:
\keywords{kompilacja, języki programowania, analiza semantyczna,
  NianioLang, system typów}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}

\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
W pracy opisujemy...
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Wprowadzenie}
  \addcontentsline{toc}{chapter}{Wprowadzenie}
  NianioLang jest językiem programowania ogólnego przeznaczenia, którego twórcą jest
  założyciel firmy Atinea -- Andrzej Gąsienica-Samek.
  Istniejący kompilator umożliwia translację NianioLanga do kilu języków,
  między innymi do Javy, JavaScriptu i C.
  Ze względu na chęć uproszczenia kompilacji NianioLanga
  utworzono środowisko uruchomieniowe dostarczające odpowiednie abstrakcje
  i pozwalające na korzystanie w C z dynamicznych struktur odpowiadających typom,
  jakie są dostępne do użycia w NianioLangu. Takie rozwiązanie nie jest
  niestety optymalne, szczególnie w przypadku niskopoziomowego języka jakim
  jest C. W tej pracy opisujemy wprowadzenie nowych typów danych i ich wsparcia
  w kompilatorze, co umożliwi generowanie natywnego kodu w C i znacznie
  zwiększy wydajność kompilowanych aplikacji przy zachowaniu podstawowych założeń języka.
\chapter{Wstęp}
\section{Wprowadzenie do NianioLanga}
NianioLang jest proceduralnym, imperatywnym językiem, którego celem jest uproszczenie pisania rozproszonych aplikacji stosując wzorzec projektowy
Nianio\cite{wzorzec_nianio}.
Celem twórców języka jest dostarczenie narzędzia umożliwiającego operowanie na niemutowalnych strukturach
o semantyce zbliżonej do języków funkcyjnych, ale prostszego w użyciu.
Konstrukcje takie jak wskaźniki zostały usunięte, a w ich miejsce zaimplementowano system zarządzania obiektami
w pamięci przez zliczanie referencji, aby pozbyć sie jednego z najczęstszych źródeł błędów, występujących przy programowaniu niskopoziomowym.
Takie zabiegi zmniejszają nieco wydajność języka, ale jego twórcy doszli do wniosku, że zysk z wysokopoziomowego podejścia
do pisania aplikacji jest wystarczająco duży, aby tworzenie aplikacji w NianioLangu było opłacalne.

Kompilator NianioLanga jest rozwijany przez firmę Atinea, która używa NianioLanga w swoich projektach (m.in. InstaDB.com).
Kod źródłowy kompilatora jest dostępny na platformie GitHub na licencji MIT.

\section{Typy w NianioLangu}
W NianioLangu mamy doczynienia z kilkoma wbudowanymi typami. Wszelkie typy tworzone przez użytkownika, to właściwie aliasy na typy wbudowane,
co pomaga w zarządzaniu abstrakcją w programie. Dostępnych jest pięć wbudowancyh typów: 
\begin{itemize}
  \item \texttt{ptd::sim} -- liczby całkowite, zmiennoprzecinkowe oraz ciągi znaków
  \item \texttt{ptd::rec} -- rekordy, czyli odpowiedniki struktur znanych np. z C
  \item \texttt{ptd::hash} -- słowniki o kluczach będących ciągami znaków i wartościach danego typu
  \item \texttt{ptd::var} -- typ wariantowy, który reprezentuje obiekty, mogące być w dokładnie jednym z określonego zbioru stanów i dodatkowo
  zawierać dane o typie właściwym dla danego stanu
  \item \texttt{ptd::arr} -- tablice danych tego samego typu
\end{itemize}

Typy te mogą być ze sobą łączone w bardziej skompilowane konstrukcje, na przykład \texttt{ptd::arr(ptd::sim())} definiuje
typ tablicy wartości prostych, a \texttt{ptd::rec(\{a => ptd::sim(), b => ptd::sim()\})} definiuje typ rekordu o dwóch polach będących wartościami prostymi.

Podstawowymi założeniami systemu typów w NianioLangu są: niemutowalność struktur i opcjonalne typowanie.

\begin{itemize}
 \item Niemutowalność struktur w NianioLangu jest pojęciem słabszym, niż w językach funkcyjnych. Oznacza ona,
 że język daje gwarancję, iż między dwoma kolejnymi dostępami do zmiennej jej wartość nie ulegnie zmianie.
 W klasycznych językach imperatywnych, posiadających wskaźniki lub referencje nie jest to prawdą -- jeśli istnieją dwa wskaźniki
 do jednej zmiennej, wartość odczytana z jednego z nich może się zmieniać nawet bez jego jawnej modyfikacji.
 \item Opcjonalne typowanie oznacza gwarancję, że dodanie lub usunięcie typów z programu nie zmieni jego semantyki.
 W skrajnym przypadku można usunąć z programu całą informację o typach i będzie on działał bez zmian
 (oczywiście może to być ze szkodą dla łatwości utrzymania lub wydajności). Jest to podejście przeciwne do stosowanego
 w takich językach jak C++, czy Haskell, których złożone systemy typów mają istotny wpływ na semantykę programu.
\end{itemize}

W wielu językach istnieje znacznie więcej wbudowanych typów, jednak powyższe są wystarczające, aby zbudować skomplikowane aplikacje,
a jednocześnie dość proste, żeby rozpoczęcie programowania w NianioLangu nie było dla programisty wyzwaniem.
W rozdziale \textit{Kompilator NianioLanga} opisana została implementacja powyższych typów w języku C.

\section{Cele projektu}
Celem projektu jest modyfikacja kompilatora NianioLanga, w taki sposób, aby kod wynikowy w C zawierał mniejszą liczbę wywołań funkcji oraz skomplikowanych
struktur dla prostych typów istniejących już w języku C. W tym celu wprowadzone zostają nowe typy z przestrzeni nazw \texttt{own},
które będą bardziej niskopoziomowymi odpowiednikami typów z przestrzeni nazw \texttt{ptd} (mianowicie rekordy, tablice i warianty).
Dzięki nałożonym na nie ograniczeniom możliwe jest znaczne zwiększenie wydajności programów pisanych w NianioLangu przy zachowaniu
niezmienionej semantyki języka.
\section{Podstawowe pojęcia}
\chapter{Metodyka pracy}
\section{Korzystanie z systemu kontroli wersji}
\section{Zgłaszanie zmian i code review}
\section{Techniki komunikacji w zespole}

\chapter{Kompilator NianioLanga}
\section{Budowanie drzewa AST}
\section{Analiza semantyczna}
\section{Architektura nlasma}
  \emph{Rejestry, wywołania funkcji, deklaracje typów, itp.}
\section{Translacja drzewa AST do nlasma}
\section{Generowanie kodu C na podstawie nlasma}
\section{Implementacja typów NianioLanga w C}

\chapter{Zmiana systemu typów}
\section{Rozdzielenie typu \texttt{ptd::sim}}
\section{Typy \texttt{own}}
  \emph{Jaki jest cel tych typów, ich semantyka, jakie ograniczenia na ich użycie
    nakładamy (w stosunku do typów ptd).}


\chapter{Rozszerzenie nlasma}
\section{Przekazywanie informacji o typach z drzewa AST}
\section{Statyczne sprawdzanie poprawności}

\chapter{Nowe implementacje typów}
  \emph{W tej sekcji w każdym podrozdziale będziemy opisywać dlaczego
    dotychczasowe rozwiązanie było nieefektywne, jak można je
    było poprawić, które rozwiązanie wybraliśmy, dlaczego.}
\section{Typy proste}
\section{Tablice}
\section{Rekordy}
\section{Typy wariantowe}
\section{Konwersja own $\rightarrow$ im}
Konwersja ownów na imy jest naturalną potrzebą języka - pomimo że typy tak naprawdę reprezentują inne podejście do przechowywania danych, nierzadko pojawia się konieczność konwertowania jednych na drugie.
Podczas prac doszliśmy do wniosku, że przypadek konwersji imów na owny nie musi być przez język obsługiwany, przede wszystkim dlatego,
że tworzenie typu statycznego z typu dynamicznego w pewnym sensie mija się z celem korzystania z typów statycznych w ogóle,
gdyż nie zabezpiecza to przed błędem w chwili konwersji.
W drugą stronę zaś konwersja pozwala na łączenie nowego kodu ze starym oraz odejście od statycznego typowania w chwili,
gdy chcemy korzystać z funkcji obsługujących wiele typów, na przykład implementując kontenery.

Początkowo mieliśmy kilka pomysłów dotyczących sposobu implementacji. Pierwszy pomysł polegał na zapisaniu w bibliotece C języka ogólnej funkcji konwertujących owny na imy.
Szybko dostrzegliśmy wady tego podejścia, przede wszystkim trudność implementacji, dużą podatność na błędy oraz wątpliwą przenośność rozwiązania.
Szczególnie trzeci argument jest ważny, gdyż dalsze kierunki rozwoju języka prawdopodobnie przewidują przywrócenie do kompilatora możliwości kompilowania na inne języki niż C.

Drugi pomysł polegał na tym, by stworzyć funkcję-wydmuszkę, w miejsce której kompilator inline'owałby właściwą definicję ima skonwertowanego z owna.
Tutaj z kolei pojawił się problem typów rekurencyjnych (warianty) oraz puchnięcia kodu wynikowego, zawierającego bardzo podobne, potencjalnie bardzo długie sekcje.

Trzeci pomysł, który został faktycznie zrealizowany, jest pomysłem pośrednim - dla każdego typu nazwanego oraz dla każdego typu, który korzysta z funkcji-wydmuszki generować funkcję,
której wywołanie byłoby następnie podpinane. Można to w pewnym sensie porównać do generowania szablonów w C++, chociaż nasz system jest oczywiście bardziej wyspecjalizowany.

Pierwszym elementem rozwiązania jest zebranie informacji o tym, jakie funkcje należy wygenerować. Postanowiliśmy robić to w dwóch miejscach.
Po pierwsze w momencie załadowania drzewa AST modułu do type checkera przechodzimy po funkcjach definiujących typy, czy przypadkiem nie korzystają one z ownów.
Miejsce to zostało wybrane, gdyż jest to pierwsze miejsce, gdzie pojawia się konkretna już wiedza o typach zmiennych.
Po drugie podczas sprawdzania typowania funkcji za każdym razem gdy natrafimy na naszą funkcję-wydmuszkę zapamiętujemy typ argumentu, z jakim została wywołana.
Oczywiście pamiętać należy o przeskanowaniu, czy dane typy nie zawierają zagnieżdżonych ownów, do których także należy stworzyć stosowne funkcje.

Drugim elementem rozwiązania jest generowanie kodu. Jest to dosyć trywialne zagadnienie, gdyż na podstawie drzewa reprezentującego typ
po prostu wypisujemy do stringa kolejne instrukcje przypisujące. Warto zwrócić jedynie uwagę na fakt, że typy mogą być zagnieżdżone
(więc czasem trzeba wołać inną funkcję konwertującego wewnętrznego owna na ima), a dla rekordów trzeba wypisać przypisanie wszystkich wartości, kod wynikowy nie może robić tego pętlą.

Trzecim elementem jest wstrzyknięcie kodu. Skoro za miejsce generowania przyjęliśmy type checker, to nie możemy zrobić tego wcześniej.
Z drugiej strony nie widzieliśmy potrzeby robienia tego później. Chcieliśmy, by kompilator mógł jak najszybciej wrócić do normalnego trybu pracy.
Wobec tego korzystając z faktu, że sprawdzanie typów rozdzielone jest od wpisywania ich do drzewa AST, w trakcie wpisywania podmieniamy wywołania do funkcji-wydmuszki na wywołania
odpowiedniej funkcji o automatycznie generowanej nazwie. Nazwa generowana jest na postawie nazwy dla typów nazwanych oraz na podstawie zawartości
dla anonimowych - rozwiązanie to ma taką zaletę, że redukujemy liczbę identycznych funkcji w kodzie wynikowym.

W tym momencie pozostaje jedynie problem dodania definicji nowych funkcji do drzewa AST. Wygenerowany kod jest parsowany do samodzielnego modułu,
następnie przechodzi przez type checkera w sposób podobny do normalnego kodu - jest jedynie parę drobnych różnic technicznych polegających na rozwiązaniu problemu,
że taki moduł odwołuje się do funkcji, których nie ma, gdyż są w naszym oryginalnym module. Są to jednak szczegóły implementacyjne, które można zobaczyć
w kodzie kompilatora. Po przejściu przez type checker moduły są łączone w jeden. Gdy cały program przejdzie przez type checker
dalsza kompilacja przebiega tak, jakby użytkownik sam wpisał sztucznie wygenerowane funkcje.

Skoro sami generujemy funkcje i wiemy, jak wygląda drzewo AST czy nie lepiej byłoby od razu tworzyć gotowe do podczepienia moduły,
zamiast marnować czas procesora na przejście przez parser i type checker? Doszliśmy do wniosku, że czas kompilacji ma nieduże znaczenie w trakcie pisania programów.
Automatyczne tworzenie drzewa AST daje zaś gwarancję, że w przypadku dalszej ewolucji kompilatora nie trzeba będzie pamiętać o tym,
aby każda zmiana miała także i odzwierciedlenie w module generowania kodu. Ma to duże znaczenie przede wszystkim ze względu na fakt,
że podczas kompilacji zakładamy, że generowane przez nas samych struktury są poprawne, a tylko program użytkownika może zawierać błędy.

\chapter{Efekty optymalizacji i wnioski}
\section{Porównanie czasu wykonania programów}

\chapter{Wkład poszczególnych członków zespołu}
\emph{Co zrobiliśmy w rozbiciu na osoby}


\appendix

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem{wzorzec_nianio} \href{https://www.mimuw.edu.pl/~chrzaszc/BPJ20067/nianio.pdf}{LK, \textit{Wzorzec ,,Nianio'' przykład} - 2006}.

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
