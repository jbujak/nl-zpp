%
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[licencjacka]{pracamgr}

\usepackage{hyperref}

% Dane magistrantów:
\autori{Michał Borkowski}{370727}
\autorii{Jakub Bujak}{370737}
\autoriii{Marian Dziubiak}{370784}
\autoriv{Marek Puzyna}{371359}

\title{Kompilacja NianioLanga do efektywnych struktur języka C}


%\tytulang{An implementation of a difference blabalizer based on the theory of $\sigma$ -- $\rho$ phetors}

%kierunek:
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{mgr. Radosława Bartosiaka\\
  Instytut Informatyki\\
  }

% miesiąc i~rok:
\date{Maj 2018}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{
%11.0 Matematyka, Informatyka:\\
%11.1 Matematyka\\
%11.2 Statystyka\\
11.3 Informatyka\\
%11.4 Sztuczna inteligencja\\
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{D. Software\\
  D.3. Programming languages\\
  D.3.3. Language contructs and features}

% Słowa kluczowe:
\keywords{kompilacja, języki programowania, analiza semantyczna,
  NianioLang, system typów}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
\newtheorem{defi}{Definicja}[section]

% koniec definicji

\begin{document}

\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
W pracy opisujemy...
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftables

\chapter*{Wprowadzenie}
  \addcontentsline{toc}{chapter}{Wprowadzenie}
  NianioLang jest językiem programowania ogólnego przeznaczenia, którego twórcą jest
  założyciel firmy Atinea -- Andrzej Gąsienica-Samek. Poniższa praca realizowana jest
  na zlecenie firmy Atinea, która wykorzystuje NianioLang.
  Istniejący kompilator umożliwia translację NianioLanga do kilku języków,
  między innymi do Javy, JavaScriptu i C.
  Ze względu na chęć uproszczenia kompilacji NianioLanga
  utworzono środowisko uruchomieniowe dostarczające odpowiednie abstrakcje
  i pozwalające na korzystanie w C z dynamicznych struktur odpowiadających typom,
  jakie są dostępne do użycia w NianioLangu. Takie rozwiązanie nie jest
  niestety optymalne, szczególnie w przypadku niskopoziomowego języka jakim
  jest C. W tej pracy opisujemy wprowadzenie nowych typów danych i ich wsparcia
  w kompilatorze, co umożliwi generowanie natywnego kodu w C i znacznie
  zwiększy wydajność kompilowanych aplikacji przy zachowaniu podstawowych założeń języka.
\chapter{Wstęp}
\section{Wprowadzenie do NianioLanga}
NianioLang jest proceduralnym, imperatywnym językiem, którego celem jest
uproszczenie pisania rozproszonych aplikacji stosując wzorzec projektowy
Nianio\cite{wzorzec_nianio}.
Celem twórców języka jest dostarczenie narzędzia umożliwiającego operowanie na niemutowalnych strukturach
o semantyce zbliżonej do języków funkcyjnych, ale prostszego w użyciu.
Konstrukcje takie jak wskaźniki zostały usunięte, a w ich miejsce, w przypadku kompilacji do C,
zaimplementowano system zarządzania obiektami
w pamięci przez zliczanie referencji, aby pozbyć sie jednego z najczęstszych źródeł błędów, występujących przy programowaniu niskopoziomowym.
Takie zabiegi zmniejszają nieco wydajność języka, ale jego twórcy doszli do wniosku, że zysk z wysokopoziomowego podejścia
do pisania aplikacji jest wystarczająco duży, aby tworzenie aplikacji w NianioLangu było opłacalne.

Kompilator NianioLanga jest rozwijany przez firmę Atinea, która używa NianioLanga w swoich projektach (m.in. InstaDB.com).
Kod źródłowy kompilatora jest dostępny na platformie GitHub\cite{github_repo_nianiolang_original} na licencji MIT.

\section{Typy w NianioLangu}
W NianioLangu mamy doczynienia z kilkoma wbudowanymi typami. Wszelkie typy tworzone przez użytkownika, to właściwie aliasy na typy wbudowane,
co pomaga w zarządzaniu abstrakcją w programie. Dostępnych jest pięć wbudowancyh typów: 
\begin{itemize}
  \item \texttt{ptd::sim} -- liczby całkowite, zmiennoprzecinkowe oraz ciągi znaków
  \item \texttt{ptd::rec} -- rekordy, czyli odpowiedniki struktur znanych np. z C
  \item \texttt{ptd::hash} -- słowniki o kluczach będących ciągami znaków i wartościach danego typu
  \item \texttt{ptd::var} -- typ wariantowy, który reprezentuje obiekty, mogące być w dokładnie jednym z określonego zbioru stanów i dodatkowo
  zawierać dane o typie właściwym dla danego stanu
  \item \texttt{ptd::arr} -- tablice danych tego samego typu
\end{itemize}

Typy te mogą być ze sobą łączone w bardziej skompilowane konstrukcje, na przykład \texttt{ptd::arr(ptd::sim())} definiuje
typ tablicy wartości prostych, a \texttt{ptd::rec(\{a => ptd::sim(), b => ptd::sim()\})} definiuje typ rekordu o dwóch polach będących wartościami prostymi.

Podstawowymi założeniami systemu typów w NianioLangu są: niemutowalność struktur i opcjonalne typowanie.

\begin{itemize}
 \item Niemutowalność struktur w NianioLangu jest pojęciem słabszym, niż w językach funkcyjnych. Oznacza ona,
 że język daje gwarancję, iż między dwoma kolejnymi dostępami do zmiennej jej wartość nie ulegnie zmianie.
 W klasycznych językach imperatywnych, posiadających wskaźniki lub referencje nie jest to prawdą -- jeśli istnieją dwa wskaźniki
 do jednej zmiennej, wartość odczytana z jednego z nich może się zmieniać nawet bez jego jawnej modyfikacji.
 \item Opcjonalne typowanie oznacza gwarancję, że dodanie lub usunięcie typów z programu nie zmieni jego semantyki.
 W skrajnym przypadku można usunąć z programu całą informację o typach i będzie on działał bez zmian
 (oczywiście może to być ze szkodą dla łatwości utrzymania lub wydajności). Jest to podejście przeciwne do stosowanego
 w takich językach jak C++, czy Haskell, których złożone systemy typów mają istotny wpływ na semantykę programu.
\end{itemize}

W wielu językach istnieje znacznie więcej wbudowanych typów, jednak powyższe są wystarczające, aby zbudować skomplikowane aplikacje,
a jednocześnie dość proste, żeby rozpoczęcie programowania w NianioLangu nie było dla programisty wyzwaniem.
W rozdziale \textit{Kompilator NianioLanga} opisana została implementacja powyższych typów w języku C.

\section{Cele projektu}
Celem projektu była modyfikacja kompilatora NianioLanga, w taki sposób, aby kod wynikowy w C zawierał mniejszą liczbę wywołań funkcji oraz skomplikowanych
struktur dla prostych typów istniejących już w języku C.
Dzięki temu zmniejszony został czas wykonania aplikacji, pozwalając kompilatorowi GCC na zastosowanie dodatkowych optymalizacji.
W tym celu wprowadzone zostały nowe typy z przestrzeni nazw \texttt{own},
które będą bardziej niskopoziomowymi odpowiednikami typów z przestrzeni nazw \texttt{ptd} (rekordy, tablice i warianty).
Dzięki nałożonym na nie ograniczeniom możliwe jest znaczne zwiększenie wydajności programów pisanych w NianioLangu przy zachowaniu
niezmienionej semantyki języka.
Jednocześnie zmienione zostały pewne podstawowe typy, mianowicie \texttt{ptd::sim} został rozbity na
\texttt{ptd::int} oraz \texttt{ptd::string}, oraz wprowadzony został typ \texttt{ptd::bool}.
Liczby całkowite i wartości boole'owskie mają w języku C natywną reprezentację i używając ich bezpośrednio
uzyskujemy prostszy kod wynikowy w C, który jest łatwiejszy do optymalizacji przez kompilator GCC.

Skutkiem zmian jakie musiały zostać wprowadzone by osiągnąć cel projektu było utracenie możliwości
kompilacji NianioLanga do języków innych niż C do czasu implementacji nowych typów w pozostałych językach.
To zadanie pozostaje jednak poza zakresem niniejszej pracy.
\section{Podstawowe pojęcia}
\chapter{Metodyka pracy}
\section{Korzystanie z systemu kontroli wersji}
\section{Zgłaszanie zmian i code review}
\section{Techniki komunikacji w zespole}

\chapter{Kompilator NianioLanga}
\section{Budowanie drzewa AST}
Pierwszym etapem kompilacji jest parsowanie programu wejściowego do drzewa AST. Takie drzewo jest strukturą przechowującą informacje o składniowej roli wyrażeń, które przetwarzać można na dalszych etapach kompilacji. Celem jest przetworzenie tekstu programu do postaci przypominającej derywację gramatyki języka. Chociaż książkowa definicja drzewa AST mówi wyłącznie o składni, kompilator NianioLanga już na tym etapie dokonuje pewnej podstawowej analizy semantycznej, gdyż wydzielenie tych czynności spowodowałoby dużą duplikację kodu związanego z czynnością obchodzenia drzewa.

Najpierw parser próbuje przeczytać listę importowanych modułów, gdyż zgodnie ze składnią języka musi ona zostać umieszczona na początku programu. Po tym etapie następuje parsowanie listy funkcji. Każdy etap parsowania odbywa się poprzez analizę możliwie najdłuższej ilości tekstu, dopisanie błędów, ustawienie wskaźnika następnej pozycji oraz innych pomocniczych wartości, które są przechowywane w zmiennej reprezentującej stan parsera, a na końcu zwrócenie sparsowanej wartości. Nie ma znaczenia, co zwróci dana funkcja w razie błędu, gdyż wtedy kompilacja zostanie zatrzymana, a użytkownik poinformowany o błędzie. W przypadku, gdy nie jest jasne, co należy sparsować (na przykład nie wiadomo, czy oczekujemy kolejnej deklaracji importu modułu, czy definicji funkcji), próbuje się przeczytać różne wartości, aż któraś zostanie poprawnie sparsowana. Ważne jest, by różne możliwości przetwarzać od największej do najmniejszej, jeżeli reprezentacja jedna może być początkiem drugiej, np. najpierw parsować należy operatory, a dopiero potem wyrażenia, chyba że kolejność nie ma znaczenia. Przykładowo w wyrażeniu \emph{1 + 2 - 3} nie ma znaczenia, czy spróbujemy sparsować najpierw operator dodawania, czy odejmowania, ale operator musi być sparsowany zanim sparsowana zostanie liczba. Innym przykładem jest \texttt{if}, po którym może nastąpić \texttt{else} i najpierw należy spróbować sparsować blok \texttt{else} zanim przejdzie się do parsowania następnych komend.

Parsowanie funkcji odbywa się poprzez sparsowanie nagłówka, a następnie sparsowanie jej wnętrza jako jednej komendy. Przyjęte jest, że komenda może być także listą komend, co parsuje się w sposób rekurencyjny. Ułatwia to parsowanie takich komend jak \texttt{for} czy \texttt{if}. Podejście to umożliwia także tworzenie rekurencyjnych funkcji, z których każda odpowiedzialna jest za jeden element gramatyki języka. Funkcje te sposób działania opierają na opisanym w poprzednim paragrafie schemacie.

Projekt nie wymagał znaczących zmian na etapie parsowania, dlatego nie zostaną one tutaj omówione. Jedynym wyjątkiem jest dodanie sprawdzania po sparsowaniu funkcji, czy nie definiuje ona typu, a następnie wpisania tego typu do drzewa. Zostało to jednak wykonane przy użyciu dostępnych już funkcji. Jest to wykonywane, by na dalszych etapach można było zapytać o dowolny definiowany typ, co ułatwia proces kompilacji. Sytuacja błędna nie jest jednak obsługiwana, stanie się to dopiero podczas sprawdzania poprawności typów.
\section{Analiza semantyczna}
Drugim etapem kompilacji jest sprawdzenie poprawności typów. Wbrew nazwie etap ten nie ma na celu wyłącznie sprawdzenia, czy program jest poprawny typowo -- do drzewa programu wpisywane są informacje o uzyskanych typach. Jest to konieczne, by móc dopasować typy nianiolanga do typów języka wynikowego. Ponadto zachodzi tutaj analiza opisana w rozdziale \hyperref[sec:own_to_im]{Konwersja own $\rightarrow$ im}.

Na tym etapie sprawdza się, czy zaimportowane moduły faktycznie istnieją, czy definicje funkcji nie dublują się, oraz w końcu czy używane typy zgodne są z oczekiwanymi. Trzeci element rozumiany jest dwojako. Po pierwsze, jeżeli dana zmienna ma zadeklarowany przez użytkownika typ, sprawdza się, czy używana jest ona wyłącznie przez funkcje, które takiego typu oczekują.  Ze względu na nietrywialny system typów wydzielone są specjalne funkcje sprawdzające czy i w jakim zakresie dwa typy są zgodne. Przykładowo jeżeli \texttt{im} używany jest w kontekście \texttt{hash}, to zgodnym typem jest \texttt{hash}. Jeżeli zaś funkcja oczekuje \texttt{int} a podawany jest \texttt{array}, to zgłaszany jest błąd. W tym kontekście o typach myśleć można jako o zbiorach możliwych wartości, na których wykonywane są operacje, przede wszystkim przecięcia.

Drugie rozumienie, które stosuje type checker, jest podobne do pierwszego, lecz w kontekście wnioskowania typów na podstawie wykonywanych na nich operacji. Jeżeli dana zmienna inicjalizowana jest jako \texttt{int}, a następnie używana jako \texttt{hash}, to zgłaszany jest błąd. Warto zaznaczyć, że operacje na typach wywnioskowanych są subtelniejsze, gdyż wiele typów jest konwertowalnych na \texttt{im} oraz w drugą stronę, przez co nie jest możliwa całkowita, ścisła kontrola typów, ta ma miejsce dopiero w runtime. Ponownie, wydzielone są funkcje operujące na typach w analogii do zbiorów.

Samą budowę type checker ma podobną w pewnym sensie do parsera. W rekurencyjny sposób sprawdzamy, jakie typy mają poszczególne elementy drzewa oraz czy są one poprawne. Tak jak w parserze zapisane jest, że operator \texttt{+} zawiera słowo kluczowe \texttt{+}, tak odpowiednia funkcja w type checkerze wie, że argumenty tego operatora muszą mieć typ zwracany \texttt{int}. Ponownie pozwala to na podział funkcji w taki sposób, by każda dotyczyła jednego, jasno wyszczególnionego elementu.
\section{Architektura nlasma}
  \emph{Rejestry, wywołania funkcji, deklaracje typów, itp.}
\section{Translacja drzewa AST do nlasma}
\section{Generowanie kodu C na podstawie nlasma}
\section{Implementacja typów NianioLanga w C}

\chapter{Zmiana systemu typów}
\section{Rozdzielenie typu \texttt{ptd::sim}}
\section{Typy \texttt{own}}
  \emph{Jaki jest cel tych typów, ich semantyka, jakie ograniczenia na ich użycie
    nakładamy (w stosunku do typów ptd).}


\chapter{Rozszerzenie nlasma}
\section{Przekazywanie informacji o typach z drzewa AST}
\section{Statyczne sprawdzanie poprawności}

\chapter{Nowe implementacje typów}
  \emph{W tej sekcji w każdym podrozdziale będziemy opisywać dlaczego
    dotychczasowe rozwiązanie było nieefektywne, jak można je
    było poprawić, które rozwiązanie wybraliśmy, dlaczego.}
\section{Typy proste}
\section{Tablice}
\section{Rekordy}
\section{Typy wariantowe}
\section{Konwersja own $\rightarrow$ im}
\label{sec:own_to_im}
Konwersja typów \texttt{own} na typ \texttt{ptd::im}, który jest uniwersalną reprezentacją typów z przestrzeni \texttt{ptd},
jest naturalną potrzebą języka. Obiekty o typie z przestrzeni nazw \texttt{own} są ograniczone w zasięgu,
więc chcąc zwrócić wartość takiego obiektu lub przekazać do funkcji, która przyjmuje argumenty z przestrzeni
nazw \texttt{ptd}, musimy go przekonwertować.

Analiza przypadków użycia konwersji pokazała, że konwersja z typów \texttt{ptd} na typy \texttt{own} nie ma 
szczególnego zastosowania i nie musi być przez język obsługiwana, przede wszystkim dlatego,
że tworzenie typu statycznego z typu dynamicznego w pewnym sensie mija się z celem korzystania z typów statycznych w ogóle,
gdyż narzut wydajnościowy związany z tworzeniem obiektów typu \texttt{ptd::im}, a potem konstruowanie z nich obiektów typu \texttt{own} byłby zbyt duży.
W drugą stronę zaś konwersja pozwala na łączenie nowego kodu ze starym oraz odejście od statycznego typowania w chwili,
gdy chcemy korzystać z funkcji obsługujących wiele typów, na przykład implementując kontenery.

Istnieje wiele sposobów na implementację konwersji. Pierwszy z nich polega na zapisaniu w bibliotece C języka ogólnej funkcji konwertujących obiekty \texttt{own} na obiekty \texttt{ptd::im}.
Podejście to ma jednak wiele wad, przede wszystkim trudność implementacji, dużą podatność na błędy oraz wątpliwą przenośność rozwiązania.
Szczególnie trzeci argument jest ważny, gdyż dalsze kierunki rozwoju języka prawdopodobnie przewidują przywrócenie do kompilatora możliwości kompilowania na inne języki niż C.

Drugi sposób polega na stworzeniu funkcji-wydmuszki przyjmującej w argumencie obiekt \texttt{own}, która w trakcie kompilacji podmieniana jest na właściwy kod dokonujący konstrukcji obiektu \texttt{ptd::im}.
Duże problemy stwarza jednak implementacja dla typów rekurencyjnych (warianty) oraz puchnięcie kodu wynikowego, zawierającego bardzo podobne, potencjalnie bardzo długie sekcje.

Trzeci sposób, który został zrealizowany, jest niejako połączeniem dwóch poprzednich -- dla każdego typu
nazwanego oraz dla każdego typu, który korzysta z funkcji-wydmuszki, generowana jest funkcja,
podpinana w miejsce wydmuszki. Można to w pewnym sensie porównać do generowania szablonów w C++, aczkolwiek ten system jest bardziej wyspecjalizowany.

Pierwszym elementem rozwiązania jest zebranie informacji o tym, jakie funkcje należy wygenerować,
co przeprowadzane jest w dwóch miejscach.
Ze względu na możliwość używania typów z innych modułów, niż w danym momencie wykonywany, każdy moduł udostępniać musi komplet funkcji do rzutowania typów, które definiuje.
Najpierw, po załadowaniu drzewa AST modułu do type checkera, dokonywany jest obchód po funkcjach definiujących typy sprawdzający, czy nie definiują one typów \texttt{own}.
Miejsce to zostało wybrane, gdyż jest to pierwsze miejsce, gdzie pojawia się konkretna wiedza o typach zmiennych.
Następnie, podczas sprawdzania typów funkcji, za każdym razem, gdy napotykana jest funkcja-wydmuszka, zapamiętywany jest typ argumentu, z jakim została ona wywołana.
Typy te są również rekurencyjnie sprawdzane, czy nie zawierają innych typów \texttt{own}, do których także należy stworzyć stosowne funkcje.

Drugim elementem rozwiązania jest generowanie kodu. Tworzona jest zmienna tekstowa, która następnie wypełniana jest instrukcjami tworzącymi obiekt \texttt{ptd::im}.
Ponieważ typy mogą być zagnieżdżone, w razie potrzeb wywołują one inne funkcje konwertujące wewnętrzne obiekty \texttt{own} na \texttt{im}.
Warto podkreślić, że w przypadku typów \texttt{own::rec} oraz \texttt{own::var} funkcje rzutujące nawet podobne typy są istotnie różne.
Rzutując rekordy należy explicite przypisać wszystkie pola, nie jest możliwe zrobienie tego w ogólny sposób pętlą, zaś rzutując warianty
wykonać należy pełną instrukcję \texttt{match}.

Trzecim elementem jest wstrzyknięcie kodu. Sprawdzanie typów rozdzielone jest od wpisywania ich do drzewa AST
i w trakcie tego wpisywania podmieniane są wywołania funkcji-wydmuszki na wywołania
odpowiedniej funkcji o automatycznie generowanej nazwie. Generowana nazwa jest tworzona na postawie nazwy dla typów nazwanych, oraz na podstawie zawartości
dla typów anonimowych -- uzyskujemy w ten sposób deduplikację kodu, generując w kodzie wynikowym C tylko jedną funkcję dla danego typu.

Pozostaje jeszcze problem dodania definicji nowych funkcji do drzewa AST. Wygenerowany kod jest parsowany do samodzielnego modułu,
który przechodzi przez type checker w sposób podobny do normalnego kodu. Po przejściu przez type checker moduły są łączone w jeden. Gdy cały program przejdzie przez type checker
dalsza kompilacja przebiega tak, jak gdyby użytkownik sam utworzył sztucznie wygenerowane funkcje.

Generując funkcje, a z nich drzewo AST, można mieć wątpliwości, czy nie lepiej byłoby od razu tworzyć gotowe do podczepienia poddrzewa, czy nawet kod wynikowy w C,
zamiast marnować czas procesora na przejście przez parser i type checker. 
Zautomatyzowane tworzenie drzewa AST daje gwarancję, że w przypadku dalszej ewolucji kompilatora nie trzeba będzie pamiętać o tym,
aby każda zmiana miała odzwierciedlenie w module generowania kodu. Ze względu na dużą dynamikę rozwoju języka jest to cecha pożądana.
Ponadto zmniejszanie czasu kompilacji programów nie było głównym celem projektu, a analiza przypadków użycia wykazała, że narzut czasowy jest w pełni akceptowalny.

\chapter{Efekty optymalizacji i wnioski}
\section{Porównanie czasu wykonania programów}

\chapter{Wkład poszczególnych członków zespołu}
\emph{Co zrobiliśmy w rozbiciu na osoby}


\appendix

\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem{wzorzec_nianio} \href{https://www.mimuw.edu.pl/~chrzaszc/BPJ20067/nianio.pdf}{LK, \textit{Wzorzec ,,Nianio'' przykład} - 2006}.
\bibitem{github_repo_nianiolang_original} \href{https://github.com/nianiolang/nl}{NianioLang Compiler - GitHub}

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
